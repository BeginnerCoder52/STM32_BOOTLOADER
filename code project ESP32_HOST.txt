/*
 * crc32.c
 *
 *  Created on: Aug 19, 2025
 *      Author: Richard Acer
 */

#include "esp_crc.h"

uint32_t calculate_crc32(const uint8_t *data, size_t length) {
    return esp_crc32_le(0xFFFFFFFF, data, length);
}

/*
 * uart_link.h
 *
 *  Created on: Aug 19, 2025
 *      Author: Richard Acer
 */

#ifndef MAIN_UART_LINK_H_
#define MAIN_UART_LINK_H_

#pragma once
#include <stdint.h>
void uart_init(int tx_gpio, int rx_gpio, int uart_num, int baud);
void send_BEGIN(uint8_t part, uint32_t size, uint32_t crc32, uint32_t version);
void send_DATA(uint32_t offset, const uint8_t* data, uint16_t len);
void send_END(void);
void send_SET_PENDING(uint8_t part, uint8_t trial);
void send_REBOOT(void);
void wait_response(uint8_t expected, uint32_t timeout_ms);


#endif /* MAIN_UART_LINK_H_ */

=======
uart_link.c

#include "uart_link.h"
#include <esp_timer.h>  // Add at top

void wait_response(uint8_t expected, uint32_t timeout_ms) {
    uint8_t resp;
    uint32_t start = esp_timer_get_time() / 1000;
    while ((esp_timer_get_time() / 1000 - start) < timeout_ms) {
        if (uart_read_bytes(UART_NUM_1, &resp, 1, 10 / portTICK_PERIOD_MS) == 1) {
            if (resp == expected) return;
            else { /* Handle error, e.g., abort */ }
        }
    }
    /* Timeout error handling */
}

void uart_init(int tx, int rx, int uart_num, int baud){
  uart_config_t cfg={ .baud_rate=baud, .data_bits=UART_DATA_8_BITS,
    .parity=UART_PARITY_DISABLE, .stop_bits=UART_STOP_BITS_1, .flow_ctrl=UART_HW_FLOWCTRL_DISABLE };
  uart_param_config(uart_num,&cfg);
  uart_set_pin(uart_num, tx, rx, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
  uart_driver_install(uart_num, 4096, 4096, 0, NULL, 0);
}

static void write_bytes(const void* p, size_t n){ uart_write_bytes(UART_NUM_1, p, n); }

void send_BEGIN(uint8_t part, uint32_t size, uint32_t crc32, uint32_t version){
  uint8_t c='B'; write_bytes(&c,1);
  write_bytes(&part,1); write_bytes(&size,4); write_bytes(&crc32,4); write_bytes(&version,4);
}
void send_DATA(uint32_t offset, const uint8_t* data, uint16_t len){
  uint8_t c='D'; write_bytes(&c,1);
  write_bytes(&offset,4); write_bytes(&len,2); write_bytes(data,len);
}
void send_END(void){ uint8_t c='E'; write_bytes(&c,1); }
void send_SET_PENDING(uint8_t part, uint8_t trial){ uint8_t c='P'; write_bytes(&c,1); write_bytes(&part,1); write_bytes(&trial,1); }
void send_REBOOT(void){ uint8_t c='R'; write_bytes(&c,1); }

=======
spiffs.h
void mount_spiffs();
=======
spiffs.c

#include <esp_vfs_fat.h>
#include <esp_spiffs.h>
#include <esp_log.h>
#include "spiffs.h"
static const char* TAG = "SPIFFS";

void mount_spiffs() {
    esp_vfs_spiffs_conf_t conf = {
        .base_path = "/spiffs",
        .partition_label = NULL,
        .max_files = 5,
        .format_if_mount_failed = true
    };
    esp_err_t ret = esp_vfs_spiffs_register(&conf);
    if (ret != ESP_OK) ESP_LOGE(TAG, "SPIFFS mount failed");
}
=======
main.c

#include <stdio.h>
#include <string.h>
#include "uart_link.h"
#include "esp_crc.h"
#include "spiffs.h"  // Add

#define FW_PATH "/spiffs/firmware.bin"
#define CHUNK_SIZE 256
#define PART_CURRENT 0  // Match STM part_t
#define TRIAL_COUNT 3

void app_main(void) {
    uart_init(17, 16, UART_NUM_1, 115200);  // Example pins, adjust
    mount_spiffs();

    FILE* f = fopen(FW_PATH, "rb");
    if (!f) return;

    fseek(f, 0, SEEK_END);
    uint32_t fw_size = ftell(f);
    fseek(f, 0, SEEK_SET);

    uint8_t* buf = malloc(fw_size);
    fread(buf, 1, fw_size, f);
    fclose(f);

    uint32_t fw_crc = calculate_crc32(buf, fw_size);
    uint32_t version = 0x00010000;  // Example

    send_BEGIN(PART_CURRENT, fw_size, fw_crc, version);
    wait_response('O', 1000);  // Wait FW_OK

    for (uint32_t offset = 0; offset < fw_size; offset += CHUNK_SIZE) {
        uint16_t len = (fw_size - offset < CHUNK_SIZE) ? (fw_size - offset) : CHUNK_SIZE;
        uint8_t cs = 0;
        for (uint16_t i = 0; i < len; i++) cs ^= buf[offset + i];
        send_DATA(offset, &buf[offset], len);
        send_DATA(offset + len, &cs, 1);  // Send checksum after data (adjust send_DATA if needed)
        wait_response('A', 1000);  // Wait ACK
    }

    send_END();
    wait_response('O', 1000);  // Assume OK for END

    send_SET_PENDING(PART_CURRENT, TRIAL_COUNT);
    send_REBOOT();

    free(buf);
}
=======