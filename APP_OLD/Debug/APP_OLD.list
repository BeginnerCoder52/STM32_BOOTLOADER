
APP_OLD.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08012000  08012000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000fb4  08012130  08012130  00001130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000024  080130e4  080130e4  000020e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08013108  08013108  00002110  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  08013108  08013108  00002110  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  08013108  08013110  00002110  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08013108  08013108  00002108  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  0801310c  0801310c  0000210c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000000  20000000  20000000  00002110  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000004c  20000000  20000000  00003000  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000004c  2000004c  00003000  2**0
                  ALLOC
 11 .app_old_metadata 00000000  0801fc00  0801fc00  00002110  2**0
                  CONTENTS
 12 .ARM.attributes 00000029  00000000  00000000  00002110  2**0
                  CONTENTS, READONLY
 13 .debug_info   00001e0e  00000000  00000000  00002139  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000008fe  00000000  00000000  00003f47  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000002a8  00000000  00000000  00004848  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 000001eb  00000000  00000000  00004af0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0000285e  00000000  00000000  00004cdb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00002f0b  00000000  00000000  00007539  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000087a0  00000000  00000000  0000a444  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  00012be4  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000095c  00000000  00000000  00012c28  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000074  00000000  00000000  00013584  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08012130 <__do_global_dtors_aux>:
 8012130:	b510      	push	{r4, lr}
 8012132:	4c05      	ldr	r4, [pc, #20]	@ (8012148 <__do_global_dtors_aux+0x18>)
 8012134:	7823      	ldrb	r3, [r4, #0]
 8012136:	b933      	cbnz	r3, 8012146 <__do_global_dtors_aux+0x16>
 8012138:	4b04      	ldr	r3, [pc, #16]	@ (801214c <__do_global_dtors_aux+0x1c>)
 801213a:	b113      	cbz	r3, 8012142 <__do_global_dtors_aux+0x12>
 801213c:	4804      	ldr	r0, [pc, #16]	@ (8012150 <__do_global_dtors_aux+0x20>)
 801213e:	f3af 8000 	nop.w
 8012142:	2301      	movs	r3, #1
 8012144:	7023      	strb	r3, [r4, #0]
 8012146:	bd10      	pop	{r4, pc}
 8012148:	20000000 	.word	0x20000000
 801214c:	00000000 	.word	0x00000000
 8012150:	080130cc 	.word	0x080130cc

08012154 <frame_dummy>:
 8012154:	b508      	push	{r3, lr}
 8012156:	4b03      	ldr	r3, [pc, #12]	@ (8012164 <frame_dummy+0x10>)
 8012158:	b11b      	cbz	r3, 8012162 <frame_dummy+0xe>
 801215a:	4903      	ldr	r1, [pc, #12]	@ (8012168 <frame_dummy+0x14>)
 801215c:	4803      	ldr	r0, [pc, #12]	@ (801216c <frame_dummy+0x18>)
 801215e:	f3af 8000 	nop.w
 8012162:	bd08      	pop	{r3, pc}
 8012164:	00000000 	.word	0x00000000
 8012168:	20000004 	.word	0x20000004
 801216c:	080130cc 	.word	0x080130cc

08012170 <app_meta_write>:

#include "app_meta.h"
#include "stm32f103xx_flash_driver.h"

void app_meta_write(uint32_t addr, const app_meta_t *meta)
{
 8012170:	b580      	push	{r7, lr}
 8012172:	b082      	sub	sp, #8
 8012174:	af00      	add	r7, sp, #0
 8012176:	6078      	str	r0, [r7, #4]
 8012178:	6039      	str	r1, [r7, #0]
    FLASH_Erase(addr); // erase the 1KB page
 801217a:	6878      	ldr	r0, [r7, #4]
 801217c:	f000 f98c 	bl	8012498 <FLASH_Erase>
    FLASH_Write_Data(addr, (uint32_t*)meta, sizeof(app_meta_t) / 4);
 8012180:	2204      	movs	r2, #4
 8012182:	6839      	ldr	r1, [r7, #0]
 8012184:	6878      	ldr	r0, [r7, #4]
 8012186:	f000 f917 	bl	80123b8 <FLASH_Write_Data>
}
 801218a:	bf00      	nop
 801218c:	3708      	adds	r7, #8
 801218e:	46bd      	mov	sp, r7
 8012190:	bd80      	pop	{r7, pc}
	...

08012194 <main>:
static void my_system_reset(void);

#define APP_BASE_ADDR       0x08004000UL

int main(void)
{
 8012194:	b5b0      	push	{r4, r5, r7, lr}
 8012196:	b08a      	sub	sp, #40	@ 0x28
 8012198:	af00      	add	r7, sp, #0
    RCC_DeInit();
 801219a:	f000 fd19 	bl	8012bd0 <RCC_DeInit>

    set_vector_table();
 801219e:	f000 f847 	bl	8012230 <set_vector_table>

    MX_GPIO_Init();
 80121a2:	f000 f85b 	bl	801225c <MX_GPIO_Init>
    MX_USART1_UART_Init();
 80121a6:	f000 f873 	bl	8012290 <MX_USART1_UART_Init>

    const char msg[] = "APP_OLD running\r\n";
 80121aa:	4b1c      	ldr	r3, [pc, #112]	@ (801221c <main+0x88>)
 80121ac:	f107 0414 	add.w	r4, r7, #20
 80121b0:	461d      	mov	r5, r3
 80121b2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80121b4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80121b6:	682b      	ldr	r3, [r5, #0]
 80121b8:	8023      	strh	r3, [r4, #0]
    USART_SendData(&husart1, (uint8_t*)msg, sizeof(msg)-1);
 80121ba:	f107 0314 	add.w	r3, r7, #20
 80121be:	2211      	movs	r2, #17
 80121c0:	4619      	mov	r1, r3
 80121c2:	4817      	ldr	r0, [pc, #92]	@ (8012220 <main+0x8c>)
 80121c4:	f000 feee 	bl	8012fa4 <USART_SendData>

    for (;;)
    {
        GPIO_WritePin(GPIOA, GPIO_PIN_NO_7, 1);
 80121c8:	2201      	movs	r2, #1
 80121ca:	2107      	movs	r1, #7
 80121cc:	4815      	ldr	r0, [pc, #84]	@ (8012224 <main+0x90>)
 80121ce:	f000 fbd5 	bl	801297c <GPIO_WritePin>
        delay_ms(250);
 80121d2:	20fa      	movs	r0, #250	@ 0xfa
 80121d4:	f000 f882 	bl	80122dc <delay_ms>
        GPIO_WritePin(GPIOA, GPIO_PIN_NO_7, 0);
 80121d8:	2200      	movs	r2, #0
 80121da:	2107      	movs	r1, #7
 80121dc:	4811      	ldr	r0, [pc, #68]	@ (8012224 <main+0x90>)
 80121de:	f000 fbcd 	bl	801297c <GPIO_WritePin>
        delay_ms(250);
 80121e2:	20fa      	movs	r0, #250	@ 0xfa
 80121e4:	f000 f87a 	bl	80122dc <delay_ms>

        uint8_t ch;
        if (USART_ReceiveDataIT(&husart1, &ch, 1) == USART_READY && ch == 'U')
 80121e8:	f107 0313 	add.w	r3, r7, #19
 80121ec:	2201      	movs	r2, #1
 80121ee:	4619      	mov	r1, r3
 80121f0:	480b      	ldr	r0, [pc, #44]	@ (8012220 <main+0x8c>)
 80121f2:	f000 ff21 	bl	8013038 <USART_ReceiveDataIT>
 80121f6:	4603      	mov	r3, r0
 80121f8:	2b00      	cmp	r3, #0
 80121fa:	d1e5      	bne.n	80121c8 <main+0x34>
 80121fc:	7cfb      	ldrb	r3, [r7, #19]
 80121fe:	2b55      	cmp	r3, #85	@ 0x55
 8012200:	d1e2      	bne.n	80121c8 <main+0x34>
        {
            app_meta_t meta = {
 8012202:	4b09      	ldr	r3, [pc, #36]	@ (8012228 <main+0x94>)
 8012204:	463c      	mov	r4, r7
 8012206:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8012208:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                .magic = META_MAGIC,
                .flag = META_FLAG_FW_READY,
                .version = 0x00010000,
                .crc32 = 0
            };
            app_meta_write(APP_CURRENT_META_ADDR, &meta);
 801220c:	463b      	mov	r3, r7
 801220e:	4619      	mov	r1, r3
 8012210:	4806      	ldr	r0, [pc, #24]	@ (801222c <main+0x98>)
 8012212:	f7ff ffad 	bl	8012170 <app_meta_write>

            my_system_reset();
 8012216:	f000 f879 	bl	801230c <my_system_reset>
    {
 801221a:	e7d5      	b.n	80121c8 <main+0x34>
 801221c:	080130e4 	.word	0x080130e4
 8012220:	2000001c 	.word	0x2000001c
 8012224:	40010800 	.word	0x40010800
 8012228:	080130f8 	.word	0x080130f8
 801222c:	08011c00 	.word	0x08011c00

08012230 <set_vector_table>:
        }
    }
}

static void set_vector_table(void)
{
 8012230:	b480      	push	{r7}
 8012232:	b083      	sub	sp, #12
 8012234:	af00      	add	r7, sp, #0
    /* SCB->VTOR is at 0xE000ED08 */
    volatile uint32_t *VTOR = (volatile uint32_t*)0xE000ED08UL;
 8012236:	4b07      	ldr	r3, [pc, #28]	@ (8012254 <set_vector_table+0x24>)
 8012238:	607b      	str	r3, [r7, #4]
    *VTOR = APP_BASE_ADDR;
 801223a:	687b      	ldr	r3, [r7, #4]
 801223c:	4a06      	ldr	r2, [pc, #24]	@ (8012258 <set_vector_table+0x28>)
 801223e:	601a      	str	r2, [r3, #0]
    __asm volatile ("dsb");
 8012240:	f3bf 8f4f 	dsb	sy
    __asm volatile ("isb");
 8012244:	f3bf 8f6f 	isb	sy
}
 8012248:	bf00      	nop
 801224a:	370c      	adds	r7, #12
 801224c:	46bd      	mov	sp, r7
 801224e:	bc80      	pop	{r7}
 8012250:	4770      	bx	lr
 8012252:	bf00      	nop
 8012254:	e000ed08 	.word	0xe000ed08
 8012258:	08004000 	.word	0x08004000

0801225c <MX_GPIO_Init>:

// --- Rest of init & utils here ---

static void MX_GPIO_Init(void)
{
 801225c:	b580      	push	{r7, lr}
 801225e:	af00      	add	r7, sp, #0
    ledA7.pGPIOx = GPIOA;
 8012260:	4b09      	ldr	r3, [pc, #36]	@ (8012288 <MX_GPIO_Init+0x2c>)
 8012262:	4a0a      	ldr	r2, [pc, #40]	@ (801228c <MX_GPIO_Init+0x30>)
 8012264:	601a      	str	r2, [r3, #0]
    ledA7.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
 8012266:	4b08      	ldr	r3, [pc, #32]	@ (8012288 <MX_GPIO_Init+0x2c>)
 8012268:	2207      	movs	r2, #7
 801226a:	711a      	strb	r2, [r3, #4]
    ledA7.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
 801226c:	4b06      	ldr	r3, [pc, #24]	@ (8012288 <MX_GPIO_Init+0x2c>)
 801226e:	2201      	movs	r2, #1
 8012270:	715a      	strb	r2, [r3, #5]
    ledA7.GPIO_PinConfig.GPIO_PinCfgMode = GPIO_CFG_OUT_GE_PP;
 8012272:	4b05      	ldr	r3, [pc, #20]	@ (8012288 <MX_GPIO_Init+0x2c>)
 8012274:	2200      	movs	r2, #0
 8012276:	719a      	strb	r2, [r3, #6]
    ledA7.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_MEDIUM;
 8012278:	4b03      	ldr	r3, [pc, #12]	@ (8012288 <MX_GPIO_Init+0x2c>)
 801227a:	2202      	movs	r2, #2
 801227c:	71da      	strb	r2, [r3, #7]
    GPIO_Init(&ledA7);
 801227e:	4802      	ldr	r0, [pc, #8]	@ (8012288 <MX_GPIO_Init+0x2c>)
 8012280:	f000 f9cc 	bl	801261c <GPIO_Init>
}
 8012284:	bf00      	nop
 8012286:	bd80      	pop	{r7, pc}
 8012288:	20000040 	.word	0x20000040
 801228c:	40010800 	.word	0x40010800

08012290 <MX_USART1_UART_Init>:

static void MX_USART1_UART_Init(void)
{
 8012290:	b580      	push	{r7, lr}
 8012292:	af00      	add	r7, sp, #0
    husart1.pUSARTx = USART1;
 8012294:	4b0f      	ldr	r3, [pc, #60]	@ (80122d4 <MX_USART1_UART_Init+0x44>)
 8012296:	4a10      	ldr	r2, [pc, #64]	@ (80122d8 <MX_USART1_UART_Init+0x48>)
 8012298:	601a      	str	r2, [r3, #0]
    husart1.USART_Config.USART_Mode = USART_MODE_TXRX;
 801229a:	4b0e      	ldr	r3, [pc, #56]	@ (80122d4 <MX_USART1_UART_Init+0x44>)
 801229c:	2202      	movs	r2, #2
 801229e:	711a      	strb	r2, [r3, #4]
    husart1.USART_Config.USART_Baudrate = 115200;
 80122a0:	4b0c      	ldr	r3, [pc, #48]	@ (80122d4 <MX_USART1_UART_Init+0x44>)
 80122a2:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
 80122a6:	609a      	str	r2, [r3, #8]
    husart1.USART_Config.USART_NumberOfStopBits = USART_STOPBITS_1;
 80122a8:	4b0a      	ldr	r3, [pc, #40]	@ (80122d4 <MX_USART1_UART_Init+0x44>)
 80122aa:	2200      	movs	r2, #0
 80122ac:	731a      	strb	r2, [r3, #12]
    husart1.USART_Config.USART_WordLength = USART_WORDLEN_8BITS;
 80122ae:	4b09      	ldr	r3, [pc, #36]	@ (80122d4 <MX_USART1_UART_Init+0x44>)
 80122b0:	2200      	movs	r2, #0
 80122b2:	735a      	strb	r2, [r3, #13]
    husart1.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;
 80122b4:	4b07      	ldr	r3, [pc, #28]	@ (80122d4 <MX_USART1_UART_Init+0x44>)
 80122b6:	2200      	movs	r2, #0
 80122b8:	739a      	strb	r2, [r3, #14]
    husart1.USART_Config.USART_HWFLowControl = USART_HW_FLOW_CTRL_NONE;
 80122ba:	4b06      	ldr	r3, [pc, #24]	@ (80122d4 <MX_USART1_UART_Init+0x44>)
 80122bc:	2200      	movs	r2, #0
 80122be:	73da      	strb	r2, [r3, #15]
    USART_Init(&husart1);
 80122c0:	4804      	ldr	r0, [pc, #16]	@ (80122d4 <MX_USART1_UART_Init+0x44>)
 80122c2:	f000 fd91 	bl	8012de8 <USART_Init>
    USART_Start(husart1.pUSARTx);
 80122c6:	4b03      	ldr	r3, [pc, #12]	@ (80122d4 <MX_USART1_UART_Init+0x44>)
 80122c8:	681b      	ldr	r3, [r3, #0]
 80122ca:	4618      	mov	r0, r3
 80122cc:	f000 fd7c 	bl	8012dc8 <USART_Start>
}
 80122d0:	bf00      	nop
 80122d2:	bd80      	pop	{r7, pc}
 80122d4:	2000001c 	.word	0x2000001c
 80122d8:	40013800 	.word	0x40013800

080122dc <delay_ms>:

static void delay_ms(uint32_t ms)
{
 80122dc:	b480      	push	{r7}
 80122de:	b085      	sub	sp, #20
 80122e0:	af00      	add	r7, sp, #0
 80122e2:	6078      	str	r0, [r7, #4]
    for (volatile uint32_t i=0; i < ms*8000; i++);
 80122e4:	2300      	movs	r3, #0
 80122e6:	60fb      	str	r3, [r7, #12]
 80122e8:	e002      	b.n	80122f0 <delay_ms+0x14>
 80122ea:	68fb      	ldr	r3, [r7, #12]
 80122ec:	3301      	adds	r3, #1
 80122ee:	60fb      	str	r3, [r7, #12]
 80122f0:	687b      	ldr	r3, [r7, #4]
 80122f2:	f44f 52fa 	mov.w	r2, #8000	@ 0x1f40
 80122f6:	fb03 f202 	mul.w	r2, r3, r2
 80122fa:	68fb      	ldr	r3, [r7, #12]
 80122fc:	429a      	cmp	r2, r3
 80122fe:	d8f4      	bhi.n	80122ea <delay_ms+0xe>
}
 8012300:	bf00      	nop
 8012302:	bf00      	nop
 8012304:	3714      	adds	r7, #20
 8012306:	46bd      	mov	sp, r7
 8012308:	bc80      	pop	{r7}
 801230a:	4770      	bx	lr

0801230c <my_system_reset>:

static inline void my_system_reset(void)
{
 801230c:	b480      	push	{r7}
 801230e:	af00      	add	r7, sp, #0
    #define AIRCR_VECTKEY_MASK    (0x5FA << 16)
    #define SCB_AIRCR             (*(volatile uint32_t*)0xE000ED0C)
    SCB_AIRCR = AIRCR_VECTKEY_MASK | (1 << 2);
 8012310:	4b02      	ldr	r3, [pc, #8]	@ (801231c <my_system_reset+0x10>)
 8012312:	4a03      	ldr	r2, [pc, #12]	@ (8012320 <my_system_reset+0x14>)
 8012314:	601a      	str	r2, [r3, #0]
    while (1) { __asm("nop"); }
 8012316:	bf00      	nop
 8012318:	e7fd      	b.n	8012316 <my_system_reset+0xa>
 801231a:	bf00      	nop
 801231c:	e000ed0c 	.word	0xe000ed0c
 8012320:	05fa0004 	.word	0x05fa0004

08012324 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8012324:	480d      	ldr	r0, [pc, #52]	@ (801235c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8012326:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8012328:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 801232c:	480c      	ldr	r0, [pc, #48]	@ (8012360 <LoopForever+0x6>)
  ldr r1, =_edata
 801232e:	490d      	ldr	r1, [pc, #52]	@ (8012364 <LoopForever+0xa>)
  ldr r2, =_sidata
 8012330:	4a0d      	ldr	r2, [pc, #52]	@ (8012368 <LoopForever+0xe>)
  movs r3, #0
 8012332:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8012334:	e002      	b.n	801233c <LoopCopyDataInit>

08012336 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8012336:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8012338:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 801233a:	3304      	adds	r3, #4

0801233c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 801233c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 801233e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8012340:	d3f9      	bcc.n	8012336 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8012342:	4a0a      	ldr	r2, [pc, #40]	@ (801236c <LoopForever+0x12>)
  ldr r4, =_ebss
 8012344:	4c0a      	ldr	r4, [pc, #40]	@ (8012370 <LoopForever+0x16>)
  movs r3, #0
 8012346:	2300      	movs	r3, #0
  b LoopFillZerobss
 8012348:	e001      	b.n	801234e <LoopFillZerobss>

0801234a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 801234a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 801234c:	3204      	adds	r2, #4

0801234e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 801234e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8012350:	d3fb      	bcc.n	801234a <FillZerobss>


/* Call static constructors */
  bl __libc_init_array
 8012352:	f000 fe97 	bl	8013084 <__libc_init_array>
/* Call the application's entry point.*/

  bl main
 8012356:	f7ff ff1d 	bl	8012194 <main>

0801235a <LoopForever>:

LoopForever:
  b LoopForever
 801235a:	e7fe      	b.n	801235a <LoopForever>
  ldr   r0, =_estack
 801235c:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 8012360:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8012364:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 8012368:	08013108 	.word	0x08013108
  ldr r2, =_sbss
 801236c:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 8012370:	2000004c 	.word	0x2000004c

08012374 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8012374:	e7fe      	b.n	8012374 <ADC1_2_IRQHandler>
	...

08012378 <FLASH_Unlock>:
 *      Author: nphuc
 */

#include "stm32f103xx_flash_driver.h"

static inline void FLASH_Unlock(){
 8012378:	b480      	push	{r7}
 801237a:	af00      	add	r7, sp, #0
    FLASH->KEYR = 0x45670123;
 801237c:	4b04      	ldr	r3, [pc, #16]	@ (8012390 <FLASH_Unlock+0x18>)
 801237e:	4a05      	ldr	r2, [pc, #20]	@ (8012394 <FLASH_Unlock+0x1c>)
 8012380:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = 0xCDEF89AB;
 8012382:	4b03      	ldr	r3, [pc, #12]	@ (8012390 <FLASH_Unlock+0x18>)
 8012384:	4a04      	ldr	r2, [pc, #16]	@ (8012398 <FLASH_Unlock+0x20>)
 8012386:	605a      	str	r2, [r3, #4]
}
 8012388:	bf00      	nop
 801238a:	46bd      	mov	sp, r7
 801238c:	bc80      	pop	{r7}
 801238e:	4770      	bx	lr
 8012390:	40022000 	.word	0x40022000
 8012394:	45670123 	.word	0x45670123
 8012398:	cdef89ab 	.word	0xcdef89ab

0801239c <FLASH_Lock>:

static inline void FLASH_Lock(){
 801239c:	b480      	push	{r7}
 801239e:	af00      	add	r7, sp, #0
    FLASH->CR |= (1 << FLASH_CR_LOCK);
 80123a0:	4b04      	ldr	r3, [pc, #16]	@ (80123b4 <FLASH_Lock+0x18>)
 80123a2:	691b      	ldr	r3, [r3, #16]
 80123a4:	4a03      	ldr	r2, [pc, #12]	@ (80123b4 <FLASH_Lock+0x18>)
 80123a6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80123aa:	6113      	str	r3, [r2, #16]
}
 80123ac:	bf00      	nop
 80123ae:	46bd      	mov	sp, r7
 80123b0:	bc80      	pop	{r7}
 80123b2:	4770      	bx	lr
 80123b4:	40022000 	.word	0x40022000

080123b8 <FLASH_Write_Data>:

uint8_t FLASH_Write_Data(uint32_t PageAddress, uint32_t *pTxBuffer, uint16_t length){
 80123b8:	b580      	push	{r7, lr}
 80123ba:	b088      	sub	sp, #32
 80123bc:	af00      	add	r7, sp, #0
 80123be:	60f8      	str	r0, [r7, #12]
 80123c0:	60b9      	str	r1, [r7, #8]
 80123c2:	4613      	mov	r3, r2
 80123c4:	80fb      	strh	r3, [r7, #6]
	FLASH_Unlock();
 80123c6:	f7ff ffd7 	bl	8012378 <FLASH_Unlock>
	uint8_t oldPage = 0;
 80123ca:	2300      	movs	r3, #0
 80123cc:	77fb      	strb	r3, [r7, #31]
    while(length > 0){
 80123ce:	e057      	b.n	8012480 <FLASH_Write_Data+0xc8>
    	uint8_t currentPage = (PageAddress / 0x0400) & 0x0FF;
 80123d0:	68fb      	ldr	r3, [r7, #12]
 80123d2:	0a9b      	lsrs	r3, r3, #10
 80123d4:	77bb      	strb	r3, [r7, #30]
    	uint32_t pageBaseAddress = 0x08000000 + currentPage * 0x400;
 80123d6:	7fbb      	ldrb	r3, [r7, #30]
 80123d8:	f503 3300 	add.w	r3, r3, #131072	@ 0x20000
 80123dc:	029b      	lsls	r3, r3, #10
 80123de:	61bb      	str	r3, [r7, #24]
    	if(currentPage > 127) return FLASH_ERROR;
 80123e0:	f997 301e 	ldrsb.w	r3, [r7, #30]
 80123e4:	2b00      	cmp	r3, #0
 80123e6:	da01      	bge.n	80123ec <FLASH_Write_Data+0x34>
 80123e8:	2300      	movs	r3, #0
 80123ea:	e04f      	b.n	801248c <FLASH_Write_Data+0xd4>
    	if(oldPage != currentPage){
 80123ec:	7ffa      	ldrb	r2, [r7, #31]
 80123ee:	7fbb      	ldrb	r3, [r7, #30]
 80123f0:	429a      	cmp	r2, r3
 80123f2:	d004      	beq.n	80123fe <FLASH_Write_Data+0x46>
    		FLASH_Erase(pageBaseAddress);
 80123f4:	69b8      	ldr	r0, [r7, #24]
 80123f6:	f000 f84f 	bl	8012498 <FLASH_Erase>
    		oldPage = currentPage;
 80123fa:	7fbb      	ldrb	r3, [r7, #30]
 80123fc:	77fb      	strb	r3, [r7, #31]
    	}

    	uint32_t value = (*pTxBuffer);
 80123fe:	68bb      	ldr	r3, [r7, #8]
 8012400:	681b      	ldr	r3, [r3, #0]
 8012402:	617b      	str	r3, [r7, #20]
        uint16_t lower_half = (uint16_t)(value & 0xFFFF);
 8012404:	697b      	ldr	r3, [r7, #20]
 8012406:	827b      	strh	r3, [r7, #18]
        uint16_t upper_half = (uint16_t)((value >> 16) & 0xFFFF);
 8012408:	697b      	ldr	r3, [r7, #20]
 801240a:	0c1b      	lsrs	r3, r3, #16
 801240c:	823b      	strh	r3, [r7, #16]

        // Clear flags
        FLASH->SR |= (1 << FLASH_SR_EOP) | (1 << FLASH_SR_PGERR) | (1 << FLASH_SR_WRPRTERR);
 801240e:	4b21      	ldr	r3, [pc, #132]	@ (8012494 <FLASH_Write_Data+0xdc>)
 8012410:	68db      	ldr	r3, [r3, #12]
 8012412:	4a20      	ldr	r2, [pc, #128]	@ (8012494 <FLASH_Write_Data+0xdc>)
 8012414:	f043 030e 	orr.w	r3, r3, #14
 8012418:	60d3      	str	r3, [r2, #12]

        FLASH->CR |= (1 << FLASH_CR_PG); // flash programming mode
 801241a:	4b1e      	ldr	r3, [pc, #120]	@ (8012494 <FLASH_Write_Data+0xdc>)
 801241c:	691b      	ldr	r3, [r3, #16]
 801241e:	4a1d      	ldr	r2, [pc, #116]	@ (8012494 <FLASH_Write_Data+0xdc>)
 8012420:	f043 0301 	orr.w	r3, r3, #1
 8012424:	6113      	str	r3, [r2, #16]
        // Write lower_half
        *(volatile uint16_t *)PageAddress = lower_half;
 8012426:	68fb      	ldr	r3, [r7, #12]
 8012428:	8a7a      	ldrh	r2, [r7, #18]
 801242a:	801a      	strh	r2, [r3, #0]
        while (FLASH->SR & FLASH_SR_BSY);
 801242c:	bf00      	nop
 801242e:	4b19      	ldr	r3, [pc, #100]	@ (8012494 <FLASH_Write_Data+0xdc>)
 8012430:	68db      	ldr	r3, [r3, #12]

        // Write upper_half
        *(volatile uint16_t *)(PageAddress + 2) = upper_half;
 8012432:	68fb      	ldr	r3, [r7, #12]
 8012434:	3302      	adds	r3, #2
 8012436:	461a      	mov	r2, r3
 8012438:	8a3b      	ldrh	r3, [r7, #16]
 801243a:	8013      	strh	r3, [r2, #0]
        while (FLASH->SR & FLASH_SR_BSY);
 801243c:	bf00      	nop
 801243e:	4b15      	ldr	r3, [pc, #84]	@ (8012494 <FLASH_Write_Data+0xdc>)
 8012440:	68db      	ldr	r3, [r3, #12]
        FLASH->CR &= ~(1 << FLASH_CR_PG);
 8012442:	4b14      	ldr	r3, [pc, #80]	@ (8012494 <FLASH_Write_Data+0xdc>)
 8012444:	691b      	ldr	r3, [r3, #16]
 8012446:	4a13      	ldr	r2, [pc, #76]	@ (8012494 <FLASH_Write_Data+0xdc>)
 8012448:	f023 0301 	bic.w	r3, r3, #1
 801244c:	6113      	str	r3, [r2, #16]

        if(((FLASH->SR >> FLASH_SR_PGERR) & 1) || (FLASH->SR >> FLASH_SR_WRPRTERR) & 1)
 801244e:	4b11      	ldr	r3, [pc, #68]	@ (8012494 <FLASH_Write_Data+0xdc>)
 8012450:	68db      	ldr	r3, [r3, #12]
 8012452:	085b      	lsrs	r3, r3, #1
 8012454:	f003 0301 	and.w	r3, r3, #1
 8012458:	2b00      	cmp	r3, #0
 801245a:	d106      	bne.n	801246a <FLASH_Write_Data+0xb2>
 801245c:	4b0d      	ldr	r3, [pc, #52]	@ (8012494 <FLASH_Write_Data+0xdc>)
 801245e:	68db      	ldr	r3, [r3, #12]
 8012460:	089b      	lsrs	r3, r3, #2
 8012462:	f003 0301 	and.w	r3, r3, #1
 8012466:	2b00      	cmp	r3, #0
 8012468:	d001      	beq.n	801246e <FLASH_Write_Data+0xb6>
            return FLASH_ERROR;
 801246a:	2300      	movs	r3, #0
 801246c:	e00e      	b.n	801248c <FLASH_Write_Data+0xd4>

        // step to next address
        pTxBuffer++;
 801246e:	68bb      	ldr	r3, [r7, #8]
 8012470:	3304      	adds	r3, #4
 8012472:	60bb      	str	r3, [r7, #8]
        PageAddress+= 4;
 8012474:	68fb      	ldr	r3, [r7, #12]
 8012476:	3304      	adds	r3, #4
 8012478:	60fb      	str	r3, [r7, #12]
        length-= 2;
 801247a:	88fb      	ldrh	r3, [r7, #6]
 801247c:	3b02      	subs	r3, #2
 801247e:	80fb      	strh	r3, [r7, #6]
    while(length > 0){
 8012480:	88fb      	ldrh	r3, [r7, #6]
 8012482:	2b00      	cmp	r3, #0
 8012484:	d1a4      	bne.n	80123d0 <FLASH_Write_Data+0x18>
    }

    FLASH_Lock();
 8012486:	f7ff ff89 	bl	801239c <FLASH_Lock>
    return FLASH_OK;
 801248a:	2301      	movs	r3, #1
}
 801248c:	4618      	mov	r0, r3
 801248e:	3720      	adds	r7, #32
 8012490:	46bd      	mov	sp, r7
 8012492:	bd80      	pop	{r7, pc}
 8012494:	40022000 	.word	0x40022000

08012498 <FLASH_Erase>:
        PageAddress += 4;
        length--;
    }
}

void FLASH_Erase(uint32_t PageAdress) {
 8012498:	b480      	push	{r7}
 801249a:	b083      	sub	sp, #12
 801249c:	af00      	add	r7, sp, #0
 801249e:	6078      	str	r0, [r7, #4]
	// choose page erase mode
	FLASH->CR |= (1 << FLASH_CR_PER);
 80124a0:	4b10      	ldr	r3, [pc, #64]	@ (80124e4 <FLASH_Erase+0x4c>)
 80124a2:	691b      	ldr	r3, [r3, #16]
 80124a4:	4a0f      	ldr	r2, [pc, #60]	@ (80124e4 <FLASH_Erase+0x4c>)
 80124a6:	f043 0302 	orr.w	r3, r3, #2
 80124aa:	6113      	str	r3, [r2, #16]
	// select page address to erase
	FLASH->AR = PageAdress;
 80124ac:	4a0d      	ldr	r2, [pc, #52]	@ (80124e4 <FLASH_Erase+0x4c>)
 80124ae:	687b      	ldr	r3, [r7, #4]
 80124b0:	6153      	str	r3, [r2, #20]

	FLASH->CR |= (1 << FLASH_CR_STRT);
 80124b2:	4b0c      	ldr	r3, [pc, #48]	@ (80124e4 <FLASH_Erase+0x4c>)
 80124b4:	691b      	ldr	r3, [r3, #16]
 80124b6:	4a0b      	ldr	r2, [pc, #44]	@ (80124e4 <FLASH_Erase+0x4c>)
 80124b8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80124bc:	6113      	str	r3, [r2, #16]

	// wait BSY reset
	while((FLASH->SR >> FLASH_SR_BSY) & 1);
 80124be:	bf00      	nop
 80124c0:	4b08      	ldr	r3, [pc, #32]	@ (80124e4 <FLASH_Erase+0x4c>)
 80124c2:	68db      	ldr	r3, [r3, #12]
 80124c4:	f003 0301 	and.w	r3, r3, #1
 80124c8:	2b00      	cmp	r3, #0
 80124ca:	d1f9      	bne.n	80124c0 <FLASH_Erase+0x28>

	FLASH->CR &= ~(1 << FLASH_CR_PER);
 80124cc:	4b05      	ldr	r3, [pc, #20]	@ (80124e4 <FLASH_Erase+0x4c>)
 80124ce:	691b      	ldr	r3, [r3, #16]
 80124d0:	4a04      	ldr	r2, [pc, #16]	@ (80124e4 <FLASH_Erase+0x4c>)
 80124d2:	f023 0302 	bic.w	r3, r3, #2
 80124d6:	6113      	str	r3, [r2, #16]
}
 80124d8:	bf00      	nop
 80124da:	370c      	adds	r7, #12
 80124dc:	46bd      	mov	sp, r7
 80124de:	bc80      	pop	{r7}
 80124e0:	4770      	bx	lr
 80124e2:	bf00      	nop
 80124e4:	40022000 	.word	0x40022000

080124e8 <GPIO_PeriClockControl>:
 * @Note              -  none

 */

void GPIO_PeriClockControl(GPIO_TypeDef_t *pGPIOx, uint8_t EnorDi)
{
 80124e8:	b480      	push	{r7}
 80124ea:	b083      	sub	sp, #12
 80124ec:	af00      	add	r7, sp, #0
 80124ee:	6078      	str	r0, [r7, #4]
 80124f0:	460b      	mov	r3, r1
 80124f2:	70fb      	strb	r3, [r7, #3]
	if (EnorDi == ENABLE)
 80124f4:	78fb      	ldrb	r3, [r7, #3]
 80124f6:	2b01      	cmp	r3, #1
 80124f8:	d11f      	bne.n	801253a <GPIO_PeriClockControl+0x52>
	{
		if (pGPIOx == GPIOA)
 80124fa:	687b      	ldr	r3, [r7, #4]
 80124fc:	4a11      	ldr	r2, [pc, #68]	@ (8012544 <GPIO_PeriClockControl+0x5c>)
 80124fe:	4293      	cmp	r3, r2
 8012500:	d106      	bne.n	8012510 <GPIO_PeriClockControl+0x28>
		{
			GPIOA_PCLK_EN();
 8012502:	4b11      	ldr	r3, [pc, #68]	@ (8012548 <GPIO_PeriClockControl+0x60>)
 8012504:	699b      	ldr	r3, [r3, #24]
 8012506:	4a10      	ldr	r2, [pc, #64]	@ (8012548 <GPIO_PeriClockControl+0x60>)
 8012508:	f043 0304 	orr.w	r3, r3, #4
 801250c:	6193      	str	r3, [r2, #24]
		else if (pGPIOx == GPIOC)
		{
			GPIOC_PCLK_EN();
		}
	}
}
 801250e:	e014      	b.n	801253a <GPIO_PeriClockControl+0x52>
		else if (pGPIOx == GPIOB)
 8012510:	687b      	ldr	r3, [r7, #4]
 8012512:	4a0e      	ldr	r2, [pc, #56]	@ (801254c <GPIO_PeriClockControl+0x64>)
 8012514:	4293      	cmp	r3, r2
 8012516:	d106      	bne.n	8012526 <GPIO_PeriClockControl+0x3e>
			GPIOB_PCLK_EN();
 8012518:	4b0b      	ldr	r3, [pc, #44]	@ (8012548 <GPIO_PeriClockControl+0x60>)
 801251a:	699b      	ldr	r3, [r3, #24]
 801251c:	4a0a      	ldr	r2, [pc, #40]	@ (8012548 <GPIO_PeriClockControl+0x60>)
 801251e:	f043 0308 	orr.w	r3, r3, #8
 8012522:	6193      	str	r3, [r2, #24]
}
 8012524:	e009      	b.n	801253a <GPIO_PeriClockControl+0x52>
		else if (pGPIOx == GPIOC)
 8012526:	687b      	ldr	r3, [r7, #4]
 8012528:	4a09      	ldr	r2, [pc, #36]	@ (8012550 <GPIO_PeriClockControl+0x68>)
 801252a:	4293      	cmp	r3, r2
 801252c:	d105      	bne.n	801253a <GPIO_PeriClockControl+0x52>
			GPIOC_PCLK_EN();
 801252e:	4b06      	ldr	r3, [pc, #24]	@ (8012548 <GPIO_PeriClockControl+0x60>)
 8012530:	699b      	ldr	r3, [r3, #24]
 8012532:	4a05      	ldr	r2, [pc, #20]	@ (8012548 <GPIO_PeriClockControl+0x60>)
 8012534:	f043 0310 	orr.w	r3, r3, #16
 8012538:	6193      	str	r3, [r2, #24]
}
 801253a:	bf00      	nop
 801253c:	370c      	adds	r7, #12
 801253e:	46bd      	mov	sp, r7
 8012540:	bc80      	pop	{r7}
 8012542:	4770      	bx	lr
 8012544:	40010800 	.word	0x40010800
 8012548:	40021000 	.word	0x40021000
 801254c:	40010c00 	.word	0x40010c00
 8012550:	40011000 	.word	0x40011000

08012554 <AlternativeMode_Init>:
 * @Note              -  none

 */

void AlternativeMode_Init(GPIO_Handle_t *pGPIOHandle, uint8_t posPinNumber, uint32_t *reg)
{
 8012554:	b480      	push	{r7}
 8012556:	b087      	sub	sp, #28
 8012558:	af00      	add	r7, sp, #0
 801255a:	60f8      	str	r0, [r7, #12]
 801255c:	460b      	mov	r3, r1
 801255e:	607a      	str	r2, [r7, #4]
 8012560:	72fb      	strb	r3, [r7, #11]
	// configure the alt functionality
	switch (pGPIOHandle->GPIO_PinConfig.GPIO_PinAltFunMode)
 8012562:	68fb      	ldr	r3, [r7, #12]
 8012564:	7a5b      	ldrb	r3, [r3, #9]
 8012566:	2b03      	cmp	r3, #3
 8012568:	d851      	bhi.n	801260e <AlternativeMode_Init+0xba>
 801256a:	a201      	add	r2, pc, #4	@ (adr r2, 8012570 <AlternativeMode_Init+0x1c>)
 801256c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012570:	08012581 	.word	0x08012581
 8012574:	080125bf 	.word	0x080125bf
 8012578:	080125ef 	.word	0x080125ef
 801257c:	0801260f 	.word	0x0801260f
	{
	case GPIO_ALT_MODE_OUT_PP:
		// configure the pin as a output
		uint8_t speed = pGPIOHandle->GPIO_PinConfig.GPIO_PinSpeed == 0 ? 1 : pGPIOHandle->GPIO_PinConfig.GPIO_PinSpeed;
 8012580:	68fb      	ldr	r3, [r7, #12]
 8012582:	79db      	ldrb	r3, [r3, #7]
 8012584:	2b00      	cmp	r3, #0
 8012586:	d002      	beq.n	801258e <AlternativeMode_Init+0x3a>
 8012588:	68fb      	ldr	r3, [r7, #12]
 801258a:	79db      	ldrb	r3, [r3, #7]
 801258c:	e000      	b.n	8012590 <AlternativeMode_Init+0x3c>
 801258e:	2301      	movs	r3, #1
 8012590:	75fb      	strb	r3, [r7, #23]
		(*reg) |= (speed << (4 * posPinNumber));
 8012592:	687b      	ldr	r3, [r7, #4]
 8012594:	681b      	ldr	r3, [r3, #0]
 8012596:	7df9      	ldrb	r1, [r7, #23]
 8012598:	7afa      	ldrb	r2, [r7, #11]
 801259a:	0092      	lsls	r2, r2, #2
 801259c:	fa01 f202 	lsl.w	r2, r1, r2
 80125a0:	431a      	orrs	r2, r3
 80125a2:	687b      	ldr	r3, [r7, #4]
 80125a4:	601a      	str	r2, [r3, #0]

		// configure alternative push pull
		(*reg) |= (GPIO_CFG_OUT_AL_PP << (4 * posPinNumber + 2));
 80125a6:	687b      	ldr	r3, [r7, #4]
 80125a8:	681b      	ldr	r3, [r3, #0]
 80125aa:	7afa      	ldrb	r2, [r7, #11]
 80125ac:	0092      	lsls	r2, r2, #2
 80125ae:	3202      	adds	r2, #2
 80125b0:	2102      	movs	r1, #2
 80125b2:	fa01 f202 	lsl.w	r2, r1, r2
 80125b6:	431a      	orrs	r2, r3
 80125b8:	687b      	ldr	r3, [r7, #4]
 80125ba:	601a      	str	r2, [r3, #0]
		break;
 80125bc:	e028      	b.n	8012610 <AlternativeMode_Init+0xbc>
	case GPIO_ALT_MODE_OUT_OD:
		// configure the pin as a output
		(*reg) |= (pGPIOHandle->GPIO_PinConfig.GPIO_PinSpeed << (4 * posPinNumber));
 80125be:	687b      	ldr	r3, [r7, #4]
 80125c0:	681b      	ldr	r3, [r3, #0]
 80125c2:	68fa      	ldr	r2, [r7, #12]
 80125c4:	79d2      	ldrb	r2, [r2, #7]
 80125c6:	4611      	mov	r1, r2
 80125c8:	7afa      	ldrb	r2, [r7, #11]
 80125ca:	0092      	lsls	r2, r2, #2
 80125cc:	fa01 f202 	lsl.w	r2, r1, r2
 80125d0:	431a      	orrs	r2, r3
 80125d2:	687b      	ldr	r3, [r7, #4]
 80125d4:	601a      	str	r2, [r3, #0]

		// configure alternative open drain
		*reg |= (GPIO_CFG_OUT_GE_OD << (4 * posPinNumber + 2));
 80125d6:	687b      	ldr	r3, [r7, #4]
 80125d8:	681b      	ldr	r3, [r3, #0]
 80125da:	7afa      	ldrb	r2, [r7, #11]
 80125dc:	0092      	lsls	r2, r2, #2
 80125de:	3202      	adds	r2, #2
 80125e0:	2101      	movs	r1, #1
 80125e2:	fa01 f202 	lsl.w	r2, r1, r2
 80125e6:	431a      	orrs	r2, r3
 80125e8:	687b      	ldr	r3, [r7, #4]
 80125ea:	601a      	str	r2, [r3, #0]
		break;
 80125ec:	e010      	b.n	8012610 <AlternativeMode_Init+0xbc>
	case GPIO_ALT_MODE_IN_FLOATING:
		// configure the pin as a input
		(*reg) |= (GPIO_MODE_IN << (4 * posPinNumber));
 80125ee:	687b      	ldr	r3, [r7, #4]
 80125f0:	681a      	ldr	r2, [r3, #0]
 80125f2:	687b      	ldr	r3, [r7, #4]
 80125f4:	601a      	str	r2, [r3, #0]

		// configure input floating
		(*reg) |= (GPIO_CFG_IN_FLOATING << (4 * posPinNumber + 2));
 80125f6:	687b      	ldr	r3, [r7, #4]
 80125f8:	681b      	ldr	r3, [r3, #0]
 80125fa:	7afa      	ldrb	r2, [r7, #11]
 80125fc:	0092      	lsls	r2, r2, #2
 80125fe:	3202      	adds	r2, #2
 8012600:	2101      	movs	r1, #1
 8012602:	fa01 f202 	lsl.w	r2, r1, r2
 8012606:	431a      	orrs	r2, r3
 8012608:	687b      	ldr	r3, [r7, #4]
 801260a:	601a      	str	r2, [r3, #0]
		break;
 801260c:	e000      	b.n	8012610 <AlternativeMode_Init+0xbc>
	case GPIO_ALT_MODE_IN_PUPD:
		break;
	default:
		break;
 801260e:	bf00      	nop
	}
}
 8012610:	bf00      	nop
 8012612:	371c      	adds	r7, #28
 8012614:	46bd      	mov	sp, r7
 8012616:	bc80      	pop	{r7}
 8012618:	4770      	bx	lr
 801261a:	bf00      	nop

0801261c <GPIO_Init>:

void GPIO_Init(GPIO_Handle_t *pGPIOHandle)
{
 801261c:	b580      	push	{r7, lr}
 801261e:	b086      	sub	sp, #24
 8012620:	af00      	add	r7, sp, #0
 8012622:	6078      	str	r0, [r7, #4]
	uint32_t temp = 0;
 8012624:	2300      	movs	r3, #0
 8012626:	60fb      	str	r3, [r7, #12]
	uint8_t posPinNumber = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber % 8;
 8012628:	687b      	ldr	r3, [r7, #4]
 801262a:	791b      	ldrb	r3, [r3, #4]
 801262c:	f003 0307 	and.w	r3, r3, #7
 8012630:	75fb      	strb	r3, [r7, #23]
	uint8_t posReg = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber / 8;
 8012632:	687b      	ldr	r3, [r7, #4]
 8012634:	791b      	ldrb	r3, [r3, #4]
 8012636:	08db      	lsrs	r3, r3, #3
 8012638:	75bb      	strb	r3, [r7, #22]

	// enable the peripheral clock
	GPIO_PeriClockControl(pGPIOHandle->pGPIOx, ENABLE);
 801263a:	687b      	ldr	r3, [r7, #4]
 801263c:	681b      	ldr	r3, [r3, #0]
 801263e:	2101      	movs	r1, #1
 8012640:	4618      	mov	r0, r3
 8012642:	f7ff ff51 	bl	80124e8 <GPIO_PeriClockControl>

	// 1. configure the mode of gpio pin and speed
	switch (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode)
 8012646:	687b      	ldr	r3, [r7, #4]
 8012648:	795b      	ldrb	r3, [r3, #5]
 801264a:	2b07      	cmp	r3, #7
 801264c:	f000 8124 	beq.w	8012898 <GPIO_Init+0x27c>
 8012650:	2b07      	cmp	r3, #7
 8012652:	f300 815a 	bgt.w	801290a <GPIO_Init+0x2ee>
 8012656:	2b01      	cmp	r3, #1
 8012658:	dc02      	bgt.n	8012660 <GPIO_Init+0x44>
 801265a:	2b00      	cmp	r3, #0
 801265c:	da05      	bge.n	801266a <GPIO_Init+0x4e>
 801265e:	e154      	b.n	801290a <GPIO_Init+0x2ee>
 8012660:	3b04      	subs	r3, #4
 8012662:	2b02      	cmp	r3, #2
 8012664:	f200 8151 	bhi.w	801290a <GPIO_Init+0x2ee>
 8012668:	e048      	b.n	80126fc <GPIO_Init+0xe0>
	{
	case GPIO_MODE_IN ... GPIO_MODE_OUT:
		// non interrupt
		// configure the speed
		temp |= (pGPIOHandle->GPIO_PinConfig.GPIO_PinSpeed << (4 * posPinNumber));
 801266a:	687b      	ldr	r3, [r7, #4]
 801266c:	79db      	ldrb	r3, [r3, #7]
 801266e:	461a      	mov	r2, r3
 8012670:	7dfb      	ldrb	r3, [r7, #23]
 8012672:	009b      	lsls	r3, r3, #2
 8012674:	fa02 f303 	lsl.w	r3, r2, r3
 8012678:	461a      	mov	r2, r3
 801267a:	68fb      	ldr	r3, [r7, #12]
 801267c:	4313      	orrs	r3, r2
 801267e:	60fb      	str	r3, [r7, #12]
		temp |= (pGPIOHandle->GPIO_PinConfig.GPIO_PinCfgMode << (4 * posPinNumber + 2));
 8012680:	687b      	ldr	r3, [r7, #4]
 8012682:	799b      	ldrb	r3, [r3, #6]
 8012684:	461a      	mov	r2, r3
 8012686:	7dfb      	ldrb	r3, [r7, #23]
 8012688:	009b      	lsls	r3, r3, #2
 801268a:	3302      	adds	r3, #2
 801268c:	fa02 f303 	lsl.w	r3, r2, r3
 8012690:	461a      	mov	r2, r3
 8012692:	68fb      	ldr	r3, [r7, #12]
 8012694:	4313      	orrs	r3, r2
 8012696:	60fb      	str	r3, [r7, #12]
		pGPIOHandle->pGPIOx->CR[posReg] &= ~(3 << (4 * posPinNumber));
 8012698:	687b      	ldr	r3, [r7, #4]
 801269a:	681b      	ldr	r3, [r3, #0]
 801269c:	7dba      	ldrb	r2, [r7, #22]
 801269e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80126a2:	7dfb      	ldrb	r3, [r7, #23]
 80126a4:	009b      	lsls	r3, r3, #2
 80126a6:	2203      	movs	r2, #3
 80126a8:	fa02 f303 	lsl.w	r3, r2, r3
 80126ac:	43db      	mvns	r3, r3
 80126ae:	4618      	mov	r0, r3
 80126b0:	687b      	ldr	r3, [r7, #4]
 80126b2:	681b      	ldr	r3, [r3, #0]
 80126b4:	7dba      	ldrb	r2, [r7, #22]
 80126b6:	4001      	ands	r1, r0
 80126b8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		pGPIOHandle->pGPIOx->CR[posReg] &= ~(3 << (4 * posPinNumber + 2));
 80126bc:	687b      	ldr	r3, [r7, #4]
 80126be:	681b      	ldr	r3, [r3, #0]
 80126c0:	7dba      	ldrb	r2, [r7, #22]
 80126c2:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80126c6:	7dfb      	ldrb	r3, [r7, #23]
 80126c8:	009b      	lsls	r3, r3, #2
 80126ca:	3302      	adds	r3, #2
 80126cc:	2203      	movs	r2, #3
 80126ce:	fa02 f303 	lsl.w	r3, r2, r3
 80126d2:	43db      	mvns	r3, r3
 80126d4:	4618      	mov	r0, r3
 80126d6:	687b      	ldr	r3, [r7, #4]
 80126d8:	681b      	ldr	r3, [r3, #0]
 80126da:	7dba      	ldrb	r2, [r7, #22]
 80126dc:	4001      	ands	r1, r0
 80126de:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		// configure control function (output open drain/push pull, input floating/pull up/pull down)
		pGPIOHandle->pGPIOx->CR[posReg] |= temp;
 80126e2:	687b      	ldr	r3, [r7, #4]
 80126e4:	681b      	ldr	r3, [r3, #0]
 80126e6:	7dba      	ldrb	r2, [r7, #22]
 80126e8:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 80126ec:	68f9      	ldr	r1, [r7, #12]
 80126ee:	687b      	ldr	r3, [r7, #4]
 80126f0:	681b      	ldr	r3, [r3, #0]
 80126f2:	7dba      	ldrb	r2, [r7, #22]
 80126f4:	4301      	orrs	r1, r0
 80126f6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		break;
 80126fa:	e106      	b.n	801290a <GPIO_Init+0x2ee>
	case GPIO_MODE_IT_FT ... GPIO_MODE_IT_RFT:
		// interrupt mode
		if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IT_FT)
 80126fc:	687b      	ldr	r3, [r7, #4]
 80126fe:	795b      	ldrb	r3, [r3, #5]
 8012700:	2b04      	cmp	r3, #4
 8012702:	d142      	bne.n	801278a <GPIO_Init+0x16e>
		{
			temp |= (pGPIOHandle->GPIO_PinConfig.GPIO_PinCfgMode << (4 * posPinNumber + 2));
 8012704:	687b      	ldr	r3, [r7, #4]
 8012706:	799b      	ldrb	r3, [r3, #6]
 8012708:	461a      	mov	r2, r3
 801270a:	7dfb      	ldrb	r3, [r7, #23]
 801270c:	009b      	lsls	r3, r3, #2
 801270e:	3302      	adds	r3, #2
 8012710:	fa02 f303 	lsl.w	r3, r2, r3
 8012714:	461a      	mov	r2, r3
 8012716:	68fb      	ldr	r3, [r7, #12]
 8012718:	4313      	orrs	r3, r2
 801271a:	60fb      	str	r3, [r7, #12]
			pGPIOHandle->pGPIOx->CR[posReg] &= ~(3 << (4 * posPinNumber + 2));
 801271c:	687b      	ldr	r3, [r7, #4]
 801271e:	681b      	ldr	r3, [r3, #0]
 8012720:	7dba      	ldrb	r2, [r7, #22]
 8012722:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8012726:	7dfb      	ldrb	r3, [r7, #23]
 8012728:	009b      	lsls	r3, r3, #2
 801272a:	3302      	adds	r3, #2
 801272c:	2203      	movs	r2, #3
 801272e:	fa02 f303 	lsl.w	r3, r2, r3
 8012732:	43db      	mvns	r3, r3
 8012734:	4618      	mov	r0, r3
 8012736:	687b      	ldr	r3, [r7, #4]
 8012738:	681b      	ldr	r3, [r3, #0]
 801273a:	7dba      	ldrb	r2, [r7, #22]
 801273c:	4001      	ands	r1, r0
 801273e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			pGPIOHandle->pGPIOx->CR[posReg] |= temp;
 8012742:	687b      	ldr	r3, [r7, #4]
 8012744:	681b      	ldr	r3, [r3, #0]
 8012746:	7dba      	ldrb	r2, [r7, #22]
 8012748:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 801274c:	68f9      	ldr	r1, [r7, #12]
 801274e:	687b      	ldr	r3, [r7, #4]
 8012750:	681b      	ldr	r3, [r3, #0]
 8012752:	7dba      	ldrb	r2, [r7, #22]
 8012754:	4301      	orrs	r1, r0
 8012756:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			// 1. configure FTSR
			EXTI->FTSR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 801275a:	4b7f      	ldr	r3, [pc, #508]	@ (8012958 <GPIO_Init+0x33c>)
 801275c:	68db      	ldr	r3, [r3, #12]
 801275e:	687a      	ldr	r2, [r7, #4]
 8012760:	7912      	ldrb	r2, [r2, #4]
 8012762:	4611      	mov	r1, r2
 8012764:	2201      	movs	r2, #1
 8012766:	408a      	lsls	r2, r1
 8012768:	4611      	mov	r1, r2
 801276a:	4a7b      	ldr	r2, [pc, #492]	@ (8012958 <GPIO_Init+0x33c>)
 801276c:	430b      	orrs	r3, r1
 801276e:	60d3      	str	r3, [r2, #12]
			// clear the corresponding RTSR bit
			EXTI->RTSR &= ~(1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 8012770:	4b79      	ldr	r3, [pc, #484]	@ (8012958 <GPIO_Init+0x33c>)
 8012772:	689b      	ldr	r3, [r3, #8]
 8012774:	687a      	ldr	r2, [r7, #4]
 8012776:	7912      	ldrb	r2, [r2, #4]
 8012778:	4611      	mov	r1, r2
 801277a:	2201      	movs	r2, #1
 801277c:	408a      	lsls	r2, r1
 801277e:	43d2      	mvns	r2, r2
 8012780:	4611      	mov	r1, r2
 8012782:	4a75      	ldr	r2, [pc, #468]	@ (8012958 <GPIO_Init+0x33c>)
 8012784:	400b      	ands	r3, r1
 8012786:	6093      	str	r3, [r2, #8]
 8012788:	e035      	b.n	80127f6 <GPIO_Init+0x1da>
		}
		else if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IT_RT)
 801278a:	687b      	ldr	r3, [r7, #4]
 801278c:	795b      	ldrb	r3, [r3, #5]
 801278e:	2b05      	cmp	r3, #5
 8012790:	d117      	bne.n	80127c2 <GPIO_Init+0x1a6>
		{
			// 1. configure RTSR
			EXTI->RTSR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 8012792:	4b71      	ldr	r3, [pc, #452]	@ (8012958 <GPIO_Init+0x33c>)
 8012794:	689b      	ldr	r3, [r3, #8]
 8012796:	687a      	ldr	r2, [r7, #4]
 8012798:	7912      	ldrb	r2, [r2, #4]
 801279a:	4611      	mov	r1, r2
 801279c:	2201      	movs	r2, #1
 801279e:	408a      	lsls	r2, r1
 80127a0:	4611      	mov	r1, r2
 80127a2:	4a6d      	ldr	r2, [pc, #436]	@ (8012958 <GPIO_Init+0x33c>)
 80127a4:	430b      	orrs	r3, r1
 80127a6:	6093      	str	r3, [r2, #8]

			// clear the corresponding FTSR bit
			EXTI->FTSR &= ~(1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 80127a8:	4b6b      	ldr	r3, [pc, #428]	@ (8012958 <GPIO_Init+0x33c>)
 80127aa:	68db      	ldr	r3, [r3, #12]
 80127ac:	687a      	ldr	r2, [r7, #4]
 80127ae:	7912      	ldrb	r2, [r2, #4]
 80127b0:	4611      	mov	r1, r2
 80127b2:	2201      	movs	r2, #1
 80127b4:	408a      	lsls	r2, r1
 80127b6:	43d2      	mvns	r2, r2
 80127b8:	4611      	mov	r1, r2
 80127ba:	4a67      	ldr	r2, [pc, #412]	@ (8012958 <GPIO_Init+0x33c>)
 80127bc:	400b      	ands	r3, r1
 80127be:	60d3      	str	r3, [r2, #12]
 80127c0:	e019      	b.n	80127f6 <GPIO_Init+0x1da>
		}
		else if (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IT_RFT)
 80127c2:	687b      	ldr	r3, [r7, #4]
 80127c4:	795b      	ldrb	r3, [r3, #5]
 80127c6:	2b06      	cmp	r3, #6
 80127c8:	d115      	bne.n	80127f6 <GPIO_Init+0x1da>
		{
			// 1. configure FTSR and RTSR
			EXTI->FTSR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 80127ca:	4b63      	ldr	r3, [pc, #396]	@ (8012958 <GPIO_Init+0x33c>)
 80127cc:	68db      	ldr	r3, [r3, #12]
 80127ce:	687a      	ldr	r2, [r7, #4]
 80127d0:	7912      	ldrb	r2, [r2, #4]
 80127d2:	4611      	mov	r1, r2
 80127d4:	2201      	movs	r2, #1
 80127d6:	408a      	lsls	r2, r1
 80127d8:	4611      	mov	r1, r2
 80127da:	4a5f      	ldr	r2, [pc, #380]	@ (8012958 <GPIO_Init+0x33c>)
 80127dc:	430b      	orrs	r3, r1
 80127de:	60d3      	str	r3, [r2, #12]
			EXTI->RTSR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 80127e0:	4b5d      	ldr	r3, [pc, #372]	@ (8012958 <GPIO_Init+0x33c>)
 80127e2:	689b      	ldr	r3, [r3, #8]
 80127e4:	687a      	ldr	r2, [r7, #4]
 80127e6:	7912      	ldrb	r2, [r2, #4]
 80127e8:	4611      	mov	r1, r2
 80127ea:	2201      	movs	r2, #1
 80127ec:	408a      	lsls	r2, r1
 80127ee:	4611      	mov	r1, r2
 80127f0:	4a59      	ldr	r2, [pc, #356]	@ (8012958 <GPIO_Init+0x33c>)
 80127f2:	430b      	orrs	r3, r1
 80127f4:	6093      	str	r3, [r2, #8]
		}

		// 2. configure the GPIO port selection in AFIO_EXTTCR
		uint8_t temp1 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber / 4;
 80127f6:	687b      	ldr	r3, [r7, #4]
 80127f8:	791b      	ldrb	r3, [r3, #4]
 80127fa:	089b      	lsrs	r3, r3, #2
 80127fc:	757b      	strb	r3, [r7, #21]
		uint8_t temp2 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber % 4;
 80127fe:	687b      	ldr	r3, [r7, #4]
 8012800:	791b      	ldrb	r3, [r3, #4]
 8012802:	f003 0303 	and.w	r3, r3, #3
 8012806:	753b      	strb	r3, [r7, #20]
		uint8_t portcode = GPIO_BASEADDR_TO_CODE(pGPIOHandle->pGPIOx);
 8012808:	687b      	ldr	r3, [r7, #4]
 801280a:	681b      	ldr	r3, [r3, #0]
 801280c:	4a53      	ldr	r2, [pc, #332]	@ (801295c <GPIO_Init+0x340>)
 801280e:	4293      	cmp	r3, r2
 8012810:	d024      	beq.n	801285c <GPIO_Init+0x240>
 8012812:	687b      	ldr	r3, [r7, #4]
 8012814:	681b      	ldr	r3, [r3, #0]
 8012816:	4a52      	ldr	r2, [pc, #328]	@ (8012960 <GPIO_Init+0x344>)
 8012818:	4293      	cmp	r3, r2
 801281a:	d01d      	beq.n	8012858 <GPIO_Init+0x23c>
 801281c:	687b      	ldr	r3, [r7, #4]
 801281e:	681b      	ldr	r3, [r3, #0]
 8012820:	4a50      	ldr	r2, [pc, #320]	@ (8012964 <GPIO_Init+0x348>)
 8012822:	4293      	cmp	r3, r2
 8012824:	d016      	beq.n	8012854 <GPIO_Init+0x238>
 8012826:	687b      	ldr	r3, [r7, #4]
 8012828:	681b      	ldr	r3, [r3, #0]
 801282a:	4a4f      	ldr	r2, [pc, #316]	@ (8012968 <GPIO_Init+0x34c>)
 801282c:	4293      	cmp	r3, r2
 801282e:	d00f      	beq.n	8012850 <GPIO_Init+0x234>
 8012830:	687b      	ldr	r3, [r7, #4]
 8012832:	681b      	ldr	r3, [r3, #0]
 8012834:	4a4d      	ldr	r2, [pc, #308]	@ (801296c <GPIO_Init+0x350>)
 8012836:	4293      	cmp	r3, r2
 8012838:	d008      	beq.n	801284c <GPIO_Init+0x230>
 801283a:	687b      	ldr	r3, [r7, #4]
 801283c:	681b      	ldr	r3, [r3, #0]
 801283e:	4a4c      	ldr	r2, [pc, #304]	@ (8012970 <GPIO_Init+0x354>)
 8012840:	4293      	cmp	r3, r2
 8012842:	d101      	bne.n	8012848 <GPIO_Init+0x22c>
 8012844:	2305      	movs	r3, #5
 8012846:	e00a      	b.n	801285e <GPIO_Init+0x242>
 8012848:	23ff      	movs	r3, #255	@ 0xff
 801284a:	e008      	b.n	801285e <GPIO_Init+0x242>
 801284c:	2304      	movs	r3, #4
 801284e:	e006      	b.n	801285e <GPIO_Init+0x242>
 8012850:	2303      	movs	r3, #3
 8012852:	e004      	b.n	801285e <GPIO_Init+0x242>
 8012854:	2302      	movs	r3, #2
 8012856:	e002      	b.n	801285e <GPIO_Init+0x242>
 8012858:	2301      	movs	r3, #1
 801285a:	e000      	b.n	801285e <GPIO_Init+0x242>
 801285c:	2300      	movs	r3, #0
 801285e:	74fb      	strb	r3, [r7, #19]

		AFIO_PCLK_EN();
 8012860:	4b44      	ldr	r3, [pc, #272]	@ (8012974 <GPIO_Init+0x358>)
 8012862:	699b      	ldr	r3, [r3, #24]
 8012864:	4a43      	ldr	r2, [pc, #268]	@ (8012974 <GPIO_Init+0x358>)
 8012866:	f043 0301 	orr.w	r3, r3, #1
 801286a:	6193      	str	r3, [r2, #24]
		AFIO->EXTTCR[temp1] = (portcode << (temp2 * 4));
 801286c:	7cfa      	ldrb	r2, [r7, #19]
 801286e:	7d3b      	ldrb	r3, [r7, #20]
 8012870:	009b      	lsls	r3, r3, #2
 8012872:	fa02 f103 	lsl.w	r1, r2, r3
 8012876:	4a40      	ldr	r2, [pc, #256]	@ (8012978 <GPIO_Init+0x35c>)
 8012878:	7d7b      	ldrb	r3, [r7, #21]
 801287a:	3302      	adds	r3, #2
 801287c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

		// 3. enable the EXTI interrupt delivery using IMR
		EXTI->IMR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 8012880:	4b35      	ldr	r3, [pc, #212]	@ (8012958 <GPIO_Init+0x33c>)
 8012882:	681b      	ldr	r3, [r3, #0]
 8012884:	687a      	ldr	r2, [r7, #4]
 8012886:	7912      	ldrb	r2, [r2, #4]
 8012888:	4611      	mov	r1, r2
 801288a:	2201      	movs	r2, #1
 801288c:	408a      	lsls	r2, r1
 801288e:	4611      	mov	r1, r2
 8012890:	4a31      	ldr	r2, [pc, #196]	@ (8012958 <GPIO_Init+0x33c>)
 8012892:	430b      	orrs	r3, r1
 8012894:	6013      	str	r3, [r2, #0]
		break;
 8012896:	e038      	b.n	801290a <GPIO_Init+0x2ee>
	case GPIO_MODE_ALTFN:
		AlternativeMode_Init(pGPIOHandle, posPinNumber, &temp);
 8012898:	f107 020c 	add.w	r2, r7, #12
 801289c:	7dfb      	ldrb	r3, [r7, #23]
 801289e:	4619      	mov	r1, r3
 80128a0:	6878      	ldr	r0, [r7, #4]
 80128a2:	f7ff fe57 	bl	8012554 <AlternativeMode_Init>

		pGPIOHandle->pGPIOx->CR[posReg] &= ~(3 << (4 * posPinNumber));
 80128a6:	687b      	ldr	r3, [r7, #4]
 80128a8:	681b      	ldr	r3, [r3, #0]
 80128aa:	7dba      	ldrb	r2, [r7, #22]
 80128ac:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80128b0:	7dfb      	ldrb	r3, [r7, #23]
 80128b2:	009b      	lsls	r3, r3, #2
 80128b4:	2203      	movs	r2, #3
 80128b6:	fa02 f303 	lsl.w	r3, r2, r3
 80128ba:	43db      	mvns	r3, r3
 80128bc:	4618      	mov	r0, r3
 80128be:	687b      	ldr	r3, [r7, #4]
 80128c0:	681b      	ldr	r3, [r3, #0]
 80128c2:	7dba      	ldrb	r2, [r7, #22]
 80128c4:	4001      	ands	r1, r0
 80128c6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		pGPIOHandle->pGPIOx->CR[posReg] &= ~(3 << (4 * posPinNumber + 2));
 80128ca:	687b      	ldr	r3, [r7, #4]
 80128cc:	681b      	ldr	r3, [r3, #0]
 80128ce:	7dba      	ldrb	r2, [r7, #22]
 80128d0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80128d4:	7dfb      	ldrb	r3, [r7, #23]
 80128d6:	009b      	lsls	r3, r3, #2
 80128d8:	3302      	adds	r3, #2
 80128da:	2203      	movs	r2, #3
 80128dc:	fa02 f303 	lsl.w	r3, r2, r3
 80128e0:	43db      	mvns	r3, r3
 80128e2:	4618      	mov	r0, r3
 80128e4:	687b      	ldr	r3, [r7, #4]
 80128e6:	681b      	ldr	r3, [r3, #0]
 80128e8:	7dba      	ldrb	r2, [r7, #22]
 80128ea:	4001      	ands	r1, r0
 80128ec:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

		pGPIOHandle->pGPIOx->CR[posReg] |= temp;
 80128f0:	687b      	ldr	r3, [r7, #4]
 80128f2:	681b      	ldr	r3, [r3, #0]
 80128f4:	7dba      	ldrb	r2, [r7, #22]
 80128f6:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 80128fa:	68f9      	ldr	r1, [r7, #12]
 80128fc:	687b      	ldr	r3, [r7, #4]
 80128fe:	681b      	ldr	r3, [r3, #0]
 8012900:	7dba      	ldrb	r2, [r7, #22]
 8012902:	4301      	orrs	r1, r0
 8012904:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		break;
 8012908:	bf00      	nop
	}

	temp = 0;
 801290a:	2300      	movs	r3, #0
 801290c:	60fb      	str	r3, [r7, #12]

	// configure pull up/pull down
	temp |= (pGPIOHandle->GPIO_PinConfig.GPIO_PinPuPdControl << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 801290e:	687b      	ldr	r3, [r7, #4]
 8012910:	7a1b      	ldrb	r3, [r3, #8]
 8012912:	461a      	mov	r2, r3
 8012914:	687b      	ldr	r3, [r7, #4]
 8012916:	791b      	ldrb	r3, [r3, #4]
 8012918:	fa02 f303 	lsl.w	r3, r2, r3
 801291c:	461a      	mov	r2, r3
 801291e:	68fb      	ldr	r3, [r7, #12]
 8012920:	4313      	orrs	r3, r2
 8012922:	60fb      	str	r3, [r7, #12]

	pGPIOHandle->pGPIOx->ODR &= ~(1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 8012924:	687b      	ldr	r3, [r7, #4]
 8012926:	681b      	ldr	r3, [r3, #0]
 8012928:	68da      	ldr	r2, [r3, #12]
 801292a:	687b      	ldr	r3, [r7, #4]
 801292c:	791b      	ldrb	r3, [r3, #4]
 801292e:	4619      	mov	r1, r3
 8012930:	2301      	movs	r3, #1
 8012932:	408b      	lsls	r3, r1
 8012934:	43db      	mvns	r3, r3
 8012936:	4619      	mov	r1, r3
 8012938:	687b      	ldr	r3, [r7, #4]
 801293a:	681b      	ldr	r3, [r3, #0]
 801293c:	400a      	ands	r2, r1
 801293e:	60da      	str	r2, [r3, #12]
	pGPIOHandle->pGPIOx->ODR |= temp;
 8012940:	687b      	ldr	r3, [r7, #4]
 8012942:	681b      	ldr	r3, [r3, #0]
 8012944:	68d9      	ldr	r1, [r3, #12]
 8012946:	68fa      	ldr	r2, [r7, #12]
 8012948:	687b      	ldr	r3, [r7, #4]
 801294a:	681b      	ldr	r3, [r3, #0]
 801294c:	430a      	orrs	r2, r1
 801294e:	60da      	str	r2, [r3, #12]
}
 8012950:	bf00      	nop
 8012952:	3718      	adds	r7, #24
 8012954:	46bd      	mov	sp, r7
 8012956:	bd80      	pop	{r7, pc}
 8012958:	40010400 	.word	0x40010400
 801295c:	40010800 	.word	0x40010800
 8012960:	40010c00 	.word	0x40010c00
 8012964:	40011000 	.word	0x40011000
 8012968:	40011400 	.word	0x40011400
 801296c:	40011800 	.word	0x40011800
 8012970:	40012000 	.word	0x40012000
 8012974:	40021000 	.word	0x40021000
 8012978:	40010000 	.word	0x40010000

0801297c <GPIO_WritePin>:
	value = (uint16_t)(pGPIOx->IDR);
	return value;
}

void GPIO_WritePin(GPIO_TypeDef_t *pGPIOx, uint8_t PinNumber, uint8_t Value)
{
 801297c:	b480      	push	{r7}
 801297e:	b083      	sub	sp, #12
 8012980:	af00      	add	r7, sp, #0
 8012982:	6078      	str	r0, [r7, #4]
 8012984:	460b      	mov	r3, r1
 8012986:	70fb      	strb	r3, [r7, #3]
 8012988:	4613      	mov	r3, r2
 801298a:	70bb      	strb	r3, [r7, #2]
	if (Value == GPIO_PIN_SET)
 801298c:	78bb      	ldrb	r3, [r7, #2]
 801298e:	2b01      	cmp	r3, #1
 8012990:	d109      	bne.n	80129a6 <GPIO_WritePin+0x2a>
	{
		// write 1 to the output data register at the bit field corressponding to the pin number
		pGPIOx->ODR |= (1 << PinNumber);
 8012992:	687b      	ldr	r3, [r7, #4]
 8012994:	68db      	ldr	r3, [r3, #12]
 8012996:	78fa      	ldrb	r2, [r7, #3]
 8012998:	2101      	movs	r1, #1
 801299a:	fa01 f202 	lsl.w	r2, r1, r2
 801299e:	431a      	orrs	r2, r3
 80129a0:	687b      	ldr	r3, [r7, #4]
 80129a2:	60da      	str	r2, [r3, #12]
	else
	{
		// write 0 to the output data register at the bit field corressponding to the pin number
		pGPIOx->ODR &= ~(1 << PinNumber);
	}
}
 80129a4:	e009      	b.n	80129ba <GPIO_WritePin+0x3e>
		pGPIOx->ODR &= ~(1 << PinNumber);
 80129a6:	687b      	ldr	r3, [r7, #4]
 80129a8:	68db      	ldr	r3, [r3, #12]
 80129aa:	78fa      	ldrb	r2, [r7, #3]
 80129ac:	2101      	movs	r1, #1
 80129ae:	fa01 f202 	lsl.w	r2, r1, r2
 80129b2:	43d2      	mvns	r2, r2
 80129b4:	401a      	ands	r2, r3
 80129b6:	687b      	ldr	r3, [r7, #4]
 80129b8:	60da      	str	r2, [r3, #12]
}
 80129ba:	bf00      	nop
 80129bc:	370c      	adds	r7, #12
 80129be:	46bd      	mov	sp, r7
 80129c0:	bc80      	pop	{r7}
 80129c2:	4770      	bx	lr

080129c4 <GPIO_IRQHandling>:
{
	pGPIOx->ODR ^= (1 << PinNumber);
}

void GPIO_IRQHandling(uint8_t PinNumber)
{ // call when IRQ occur
 80129c4:	b580      	push	{r7, lr}
 80129c6:	b082      	sub	sp, #8
 80129c8:	af00      	add	r7, sp, #0
 80129ca:	4603      	mov	r3, r0
 80129cc:	71fb      	strb	r3, [r7, #7]
	// clear
	EXTI->PR |= (1 << PinNumber);
 80129ce:	4b09      	ldr	r3, [pc, #36]	@ (80129f4 <GPIO_IRQHandling+0x30>)
 80129d0:	695b      	ldr	r3, [r3, #20]
 80129d2:	79fa      	ldrb	r2, [r7, #7]
 80129d4:	2101      	movs	r1, #1
 80129d6:	fa01 f202 	lsl.w	r2, r1, r2
 80129da:	4611      	mov	r1, r2
 80129dc:	4a05      	ldr	r2, [pc, #20]	@ (80129f4 <GPIO_IRQHandling+0x30>)
 80129de:	430b      	orrs	r3, r1
 80129e0:	6153      	str	r3, [r2, #20]
	GPIO_ExternalInterruptEventsCallback(PinNumber);
 80129e2:	79fb      	ldrb	r3, [r7, #7]
 80129e4:	4618      	mov	r0, r3
 80129e6:	f000 f86f 	bl	8012ac8 <GPIO_ExternalInterruptEventsCallback>
}
 80129ea:	bf00      	nop
 80129ec:	3708      	adds	r7, #8
 80129ee:	46bd      	mov	sp, r7
 80129f0:	bd80      	pop	{r7, pc}
 80129f2:	bf00      	nop
 80129f4:	40010400 	.word	0x40010400

080129f8 <EXTI0_IRQHandler>:

void EXTI0_IRQHandler()
{
 80129f8:	b580      	push	{r7, lr}
 80129fa:	af00      	add	r7, sp, #0
	GPIO_IRQHandling(GPIO_PIN_NO_0);
 80129fc:	2000      	movs	r0, #0
 80129fe:	f7ff ffe1 	bl	80129c4 <GPIO_IRQHandling>
}
 8012a02:	bf00      	nop
 8012a04:	bd80      	pop	{r7, pc}

08012a06 <EXTI1_IRQHandler>:

void EXTI1_IRQHandler()
{
 8012a06:	b580      	push	{r7, lr}
 8012a08:	af00      	add	r7, sp, #0
	GPIO_IRQHandling(GPIO_PIN_NO_1);
 8012a0a:	2001      	movs	r0, #1
 8012a0c:	f7ff ffda 	bl	80129c4 <GPIO_IRQHandling>
}
 8012a10:	bf00      	nop
 8012a12:	bd80      	pop	{r7, pc}

08012a14 <EXTI2_IRQHandler>:

void EXTI2_IRQHandler()
{
 8012a14:	b580      	push	{r7, lr}
 8012a16:	af00      	add	r7, sp, #0
	GPIO_IRQHandling(GPIO_PIN_NO_2);
 8012a18:	2002      	movs	r0, #2
 8012a1a:	f7ff ffd3 	bl	80129c4 <GPIO_IRQHandling>
}
 8012a1e:	bf00      	nop
 8012a20:	bd80      	pop	{r7, pc}

08012a22 <EXTI3_IRQHandler>:

void EXTI3_IRQHandler()
{
 8012a22:	b580      	push	{r7, lr}
 8012a24:	af00      	add	r7, sp, #0
	GPIO_IRQHandling(GPIO_PIN_NO_3);
 8012a26:	2003      	movs	r0, #3
 8012a28:	f7ff ffcc 	bl	80129c4 <GPIO_IRQHandling>
}
 8012a2c:	bf00      	nop
 8012a2e:	bd80      	pop	{r7, pc}

08012a30 <EXTI4_IRQHandler>:

void EXTI4_IRQHandler()
{
 8012a30:	b580      	push	{r7, lr}
 8012a32:	af00      	add	r7, sp, #0
	GPIO_IRQHandling(GPIO_PIN_NO_4);
 8012a34:	2004      	movs	r0, #4
 8012a36:	f7ff ffc5 	bl	80129c4 <GPIO_IRQHandling>
}
 8012a3a:	bf00      	nop
 8012a3c:	bd80      	pop	{r7, pc}
	...

08012a40 <EXTI9_5_IRQHandler>:

void EXTI9_5_IRQHandler()
{
 8012a40:	b580      	push	{r7, lr}
 8012a42:	b082      	sub	sp, #8
 8012a44:	af00      	add	r7, sp, #0
	uint8_t pinNumber;
	for (uint8_t i = 5; i < 10; i++)
 8012a46:	2305      	movs	r3, #5
 8012a48:	71bb      	strb	r3, [r7, #6]
 8012a4a:	e00e      	b.n	8012a6a <EXTI9_5_IRQHandler+0x2a>
	{
		if ((EXTI->PR >> i) & 1)
 8012a4c:	4b0c      	ldr	r3, [pc, #48]	@ (8012a80 <EXTI9_5_IRQHandler+0x40>)
 8012a4e:	695a      	ldr	r2, [r3, #20]
 8012a50:	79bb      	ldrb	r3, [r7, #6]
 8012a52:	fa22 f303 	lsr.w	r3, r2, r3
 8012a56:	f003 0301 	and.w	r3, r3, #1
 8012a5a:	2b00      	cmp	r3, #0
 8012a5c:	d002      	beq.n	8012a64 <EXTI9_5_IRQHandler+0x24>
		{
			pinNumber = i;
 8012a5e:	79bb      	ldrb	r3, [r7, #6]
 8012a60:	71fb      	strb	r3, [r7, #7]
			break;
 8012a62:	e005      	b.n	8012a70 <EXTI9_5_IRQHandler+0x30>
	for (uint8_t i = 5; i < 10; i++)
 8012a64:	79bb      	ldrb	r3, [r7, #6]
 8012a66:	3301      	adds	r3, #1
 8012a68:	71bb      	strb	r3, [r7, #6]
 8012a6a:	79bb      	ldrb	r3, [r7, #6]
 8012a6c:	2b09      	cmp	r3, #9
 8012a6e:	d9ed      	bls.n	8012a4c <EXTI9_5_IRQHandler+0xc>
		}
	}

	GPIO_IRQHandling(pinNumber);
 8012a70:	79fb      	ldrb	r3, [r7, #7]
 8012a72:	4618      	mov	r0, r3
 8012a74:	f7ff ffa6 	bl	80129c4 <GPIO_IRQHandling>
}
 8012a78:	bf00      	nop
 8012a7a:	3708      	adds	r7, #8
 8012a7c:	46bd      	mov	sp, r7
 8012a7e:	bd80      	pop	{r7, pc}
 8012a80:	40010400 	.word	0x40010400

08012a84 <EXTI15_10_IRQHandler>:

void EXTI15_10_IRQHandler()
{
 8012a84:	b580      	push	{r7, lr}
 8012a86:	b082      	sub	sp, #8
 8012a88:	af00      	add	r7, sp, #0
	uint8_t pinNumber;
	for (uint8_t i = 10; i < 16; i++)
 8012a8a:	230a      	movs	r3, #10
 8012a8c:	71bb      	strb	r3, [r7, #6]
 8012a8e:	e00e      	b.n	8012aae <EXTI15_10_IRQHandler+0x2a>
	{
		if ((EXTI->PR >> i) & 1)
 8012a90:	4b0c      	ldr	r3, [pc, #48]	@ (8012ac4 <EXTI15_10_IRQHandler+0x40>)
 8012a92:	695a      	ldr	r2, [r3, #20]
 8012a94:	79bb      	ldrb	r3, [r7, #6]
 8012a96:	fa22 f303 	lsr.w	r3, r2, r3
 8012a9a:	f003 0301 	and.w	r3, r3, #1
 8012a9e:	2b00      	cmp	r3, #0
 8012aa0:	d002      	beq.n	8012aa8 <EXTI15_10_IRQHandler+0x24>
		{
			pinNumber = i;
 8012aa2:	79bb      	ldrb	r3, [r7, #6]
 8012aa4:	71fb      	strb	r3, [r7, #7]
			break;
 8012aa6:	e005      	b.n	8012ab4 <EXTI15_10_IRQHandler+0x30>
	for (uint8_t i = 10; i < 16; i++)
 8012aa8:	79bb      	ldrb	r3, [r7, #6]
 8012aaa:	3301      	adds	r3, #1
 8012aac:	71bb      	strb	r3, [r7, #6]
 8012aae:	79bb      	ldrb	r3, [r7, #6]
 8012ab0:	2b0f      	cmp	r3, #15
 8012ab2:	d9ed      	bls.n	8012a90 <EXTI15_10_IRQHandler+0xc>
		}
	}

	GPIO_IRQHandling(pinNumber);
 8012ab4:	79fb      	ldrb	r3, [r7, #7]
 8012ab6:	4618      	mov	r0, r3
 8012ab8:	f7ff ff84 	bl	80129c4 <GPIO_IRQHandling>
}
 8012abc:	bf00      	nop
 8012abe:	3708      	adds	r7, #8
 8012ac0:	46bd      	mov	sp, r7
 8012ac2:	bd80      	pop	{r7, pc}
 8012ac4:	40010400 	.word	0x40010400

08012ac8 <GPIO_ExternalInterruptEventsCallback>:

__weak void GPIO_ExternalInterruptEventsCallback(uint8_t PinNumber) {}
 8012ac8:	b480      	push	{r7}
 8012aca:	b083      	sub	sp, #12
 8012acc:	af00      	add	r7, sp, #0
 8012ace:	4603      	mov	r3, r0
 8012ad0:	71fb      	strb	r3, [r7, #7]
 8012ad2:	bf00      	nop
 8012ad4:	370c      	adds	r7, #12
 8012ad6:	46bd      	mov	sp, r7
 8012ad8:	bc80      	pop	{r7}
 8012ada:	4770      	bx	lr

08012adc <RCC_CIR_Reset>:
#include "stm32f103xx_rcc_driver.h"

/* ------------------------ PRIVATE ------------------------ */
static void RCC_CIR_Reset(void) {
 8012adc:	b480      	push	{r7}
 8012ade:	af00      	add	r7, sp, #0
	CLEAR_REG(RCC->CIR, 8, 0x7F);
 8012ae0:	4b0b      	ldr	r3, [pc, #44]	@ (8012b10 <RCC_CIR_Reset+0x34>)
 8012ae2:	689b      	ldr	r3, [r3, #8]
 8012ae4:	4a0a      	ldr	r2, [pc, #40]	@ (8012b10 <RCC_CIR_Reset+0x34>)
 8012ae6:	f423 43fe 	bic.w	r3, r3, #32512	@ 0x7f00
 8012aea:	6093      	str	r3, [r2, #8]

	CLEAR_REG(RCC->CIR, 16, 0xFF);
 8012aec:	4b08      	ldr	r3, [pc, #32]	@ (8012b10 <RCC_CIR_Reset+0x34>)
 8012aee:	689b      	ldr	r3, [r3, #8]
 8012af0:	4a07      	ldr	r2, [pc, #28]	@ (8012b10 <RCC_CIR_Reset+0x34>)
 8012af2:	f423 037f 	bic.w	r3, r3, #16711680	@ 0xff0000
 8012af6:	6093      	str	r3, [r2, #8]

	while(READ_REG(RCC->CIR, 0, 0xFF));
 8012af8:	bf00      	nop
 8012afa:	4b05      	ldr	r3, [pc, #20]	@ (8012b10 <RCC_CIR_Reset+0x34>)
 8012afc:	689b      	ldr	r3, [r3, #8]
 8012afe:	b2db      	uxtb	r3, r3
 8012b00:	2b00      	cmp	r3, #0
 8012b02:	d1fa      	bne.n	8012afa <RCC_CIR_Reset+0x1e>
}
 8012b04:	bf00      	nop
 8012b06:	bf00      	nop
 8012b08:	46bd      	mov	sp, r7
 8012b0a:	bc80      	pop	{r7}
 8012b0c:	4770      	bx	lr
 8012b0e:	bf00      	nop
 8012b10:	40021000 	.word	0x40021000

08012b14 <RCC_Peripheral_Reset>:

static void RCC_Peripheral_Reset(void) {
 8012b14:	b480      	push	{r7}
 8012b16:	b083      	sub	sp, #12
 8012b18:	af00      	add	r7, sp, #0
	/* Reset all peripherals */
	SET_REG(RCC->APB1RSTR, 0, 0xFFFFFFFF);
 8012b1a:	4b13      	ldr	r3, [pc, #76]	@ (8012b68 <RCC_Peripheral_Reset+0x54>)
 8012b1c:	691b      	ldr	r3, [r3, #16]
 8012b1e:	4b12      	ldr	r3, [pc, #72]	@ (8012b68 <RCC_Peripheral_Reset+0x54>)
 8012b20:	f04f 32ff 	mov.w	r2, #4294967295
 8012b24:	611a      	str	r2, [r3, #16]
	SET_REG(RCC->APB2RSTR, 0, 0xFFFFFFFF);
 8012b26:	4b10      	ldr	r3, [pc, #64]	@ (8012b68 <RCC_Peripheral_Reset+0x54>)
 8012b28:	68db      	ldr	r3, [r3, #12]
 8012b2a:	4b0f      	ldr	r3, [pc, #60]	@ (8012b68 <RCC_Peripheral_Reset+0x54>)
 8012b2c:	f04f 32ff 	mov.w	r2, #4294967295
 8012b30:	60da      	str	r2, [r3, #12]

	/* delay */
	for(__vo uint8_t i = 0; i < 100; i++);
 8012b32:	2300      	movs	r3, #0
 8012b34:	71fb      	strb	r3, [r7, #7]
 8012b36:	e004      	b.n	8012b42 <RCC_Peripheral_Reset+0x2e>
 8012b38:	79fb      	ldrb	r3, [r7, #7]
 8012b3a:	b2db      	uxtb	r3, r3
 8012b3c:	3301      	adds	r3, #1
 8012b3e:	b2db      	uxtb	r3, r3
 8012b40:	71fb      	strb	r3, [r7, #7]
 8012b42:	79fb      	ldrb	r3, [r7, #7]
 8012b44:	b2db      	uxtb	r3, r3
 8012b46:	2b63      	cmp	r3, #99	@ 0x63
 8012b48:	d9f6      	bls.n	8012b38 <RCC_Peripheral_Reset+0x24>

	/* Release peripherals */
	CLEAR_REG(RCC->APB1RSTR, 0, 0xFFFFFFFF);
 8012b4a:	4b07      	ldr	r3, [pc, #28]	@ (8012b68 <RCC_Peripheral_Reset+0x54>)
 8012b4c:	691b      	ldr	r3, [r3, #16]
 8012b4e:	4b06      	ldr	r3, [pc, #24]	@ (8012b68 <RCC_Peripheral_Reset+0x54>)
 8012b50:	2200      	movs	r2, #0
 8012b52:	611a      	str	r2, [r3, #16]
	CLEAR_REG(RCC->APB2RSTR, 0, 0xFFFFFFFF);
 8012b54:	4b04      	ldr	r3, [pc, #16]	@ (8012b68 <RCC_Peripheral_Reset+0x54>)
 8012b56:	68db      	ldr	r3, [r3, #12]
 8012b58:	4b03      	ldr	r3, [pc, #12]	@ (8012b68 <RCC_Peripheral_Reset+0x54>)
 8012b5a:	2200      	movs	r2, #0
 8012b5c:	60da      	str	r2, [r3, #12]
}
 8012b5e:	bf00      	nop
 8012b60:	370c      	adds	r7, #12
 8012b62:	46bd      	mov	sp, r7
 8012b64:	bc80      	pop	{r7}
 8012b66:	4770      	bx	lr
 8012b68:	40021000 	.word	0x40021000

08012b6c <RCC_PeripheralClock_Reset>:

static void RCC_PeripheralClock_Reset(void) {
 8012b6c:	b480      	push	{r7}
 8012b6e:	b083      	sub	sp, #12
 8012b70:	af00      	add	r7, sp, #0
	/* Release peripherals */
	CLEAR_REG(RCC->AHBENR, 0, 0xFFFFFFFF);
 8012b72:	4b16      	ldr	r3, [pc, #88]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012b74:	695b      	ldr	r3, [r3, #20]
 8012b76:	4b15      	ldr	r3, [pc, #84]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012b78:	2200      	movs	r2, #0
 8012b7a:	615a      	str	r2, [r3, #20]
	CLEAR_REG(RCC->APB1ENR, 0, 0xFFFFFFFF);
 8012b7c:	4b13      	ldr	r3, [pc, #76]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012b7e:	69db      	ldr	r3, [r3, #28]
 8012b80:	4b12      	ldr	r3, [pc, #72]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012b82:	2200      	movs	r2, #0
 8012b84:	61da      	str	r2, [r3, #28]
	CLEAR_REG(RCC->APB2ENR, 0, 0xFFFFFFFF);
 8012b86:	4b11      	ldr	r3, [pc, #68]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012b88:	699b      	ldr	r3, [r3, #24]
 8012b8a:	4b10      	ldr	r3, [pc, #64]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012b8c:	2200      	movs	r2, #0
 8012b8e:	619a      	str	r2, [r3, #24]

	for(__vo uint8_t i = 0; i < 10; i++);
 8012b90:	2300      	movs	r3, #0
 8012b92:	71fb      	strb	r3, [r7, #7]
 8012b94:	e004      	b.n	8012ba0 <RCC_PeripheralClock_Reset+0x34>
 8012b96:	79fb      	ldrb	r3, [r7, #7]
 8012b98:	b2db      	uxtb	r3, r3
 8012b9a:	3301      	adds	r3, #1
 8012b9c:	b2db      	uxtb	r3, r3
 8012b9e:	71fb      	strb	r3, [r7, #7]
 8012ba0:	79fb      	ldrb	r3, [r7, #7]
 8012ba2:	b2db      	uxtb	r3, r3
 8012ba4:	2b09      	cmp	r3, #9
 8012ba6:	d9f6      	bls.n	8012b96 <RCC_PeripheralClock_Reset+0x2a>

	SET_BIT(RCC->AHBENR, RCC_AHBENR_SRAMEN);
 8012ba8:	4b08      	ldr	r3, [pc, #32]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012baa:	695b      	ldr	r3, [r3, #20]
 8012bac:	4a07      	ldr	r2, [pc, #28]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012bae:	f043 0304 	orr.w	r3, r3, #4
 8012bb2:	6153      	str	r3, [r2, #20]
	SET_BIT(RCC->AHBENR, RCC_AHBENR_FLITFEN);
 8012bb4:	4b05      	ldr	r3, [pc, #20]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012bb6:	695b      	ldr	r3, [r3, #20]
 8012bb8:	4a04      	ldr	r2, [pc, #16]	@ (8012bcc <RCC_PeripheralClock_Reset+0x60>)
 8012bba:	f043 0310 	orr.w	r3, r3, #16
 8012bbe:	6153      	str	r3, [r2, #20]
}
 8012bc0:	bf00      	nop
 8012bc2:	370c      	adds	r7, #12
 8012bc4:	46bd      	mov	sp, r7
 8012bc6:	bc80      	pop	{r7}
 8012bc8:	4770      	bx	lr
 8012bca:	bf00      	nop
 8012bcc:	40021000 	.word	0x40021000

08012bd0 <RCC_DeInit>:

/* --------------------------------------------------------- */

/* ------------------------ PUBLIC ------------------------ */
void RCC_DeInit(void) {
 8012bd0:	b580      	push	{r7, lr}
 8012bd2:	af00      	add	r7, sp, #0
	RCC_Peripheral_Reset();
 8012bd4:	f7ff ff9e 	bl	8012b14 <RCC_Peripheral_Reset>
	/* Set HSION bit */
	RCC_HSI_ENABLE();
 8012bd8:	4b25      	ldr	r3, [pc, #148]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012bda:	681b      	ldr	r3, [r3, #0]
 8012bdc:	4a24      	ldr	r2, [pc, #144]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012bde:	f043 0301 	orr.w	r3, r3, #1
 8012be2:	6013      	str	r3, [r2, #0]
 8012be4:	4b22      	ldr	r3, [pc, #136]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012be6:	681b      	ldr	r3, [r3, #0]
 8012be8:	085b      	lsrs	r3, r3, #1
 8012bea:	f003 0301 	and.w	r3, r3, #1
 8012bee:	2b00      	cmp	r3, #0
 8012bf0:	d0f2      	beq.n	8012bd8 <RCC_DeInit+0x8>
	
	CLEAR_REG(RCC->CFGR, 0, 0xFFFFFFFF);
 8012bf2:	4b1f      	ldr	r3, [pc, #124]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012bf4:	685b      	ldr	r3, [r3, #4]
 8012bf6:	4b1e      	ldr	r3, [pc, #120]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012bf8:	2200      	movs	r2, #0
 8012bfa:	605a      	str	r2, [r3, #4]
	while(READ_REG(RCC->CFGR, RCC_CFGR_SWS, RCC_CFGR_SWS_MASK) != RCC_CFGR_SW_HSI);
 8012bfc:	bf00      	nop
 8012bfe:	4b1c      	ldr	r3, [pc, #112]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c00:	685b      	ldr	r3, [r3, #4]
 8012c02:	089b      	lsrs	r3, r3, #2
 8012c04:	f003 030c 	and.w	r3, r3, #12
 8012c08:	2b00      	cmp	r3, #0
 8012c0a:	d1f8      	bne.n	8012bfe <RCC_DeInit+0x2e>
	
	/* Disable HSE clock source */
	RCC_HSE_DISABLE();
 8012c0c:	4b18      	ldr	r3, [pc, #96]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c0e:	681b      	ldr	r3, [r3, #0]
 8012c10:	4a17      	ldr	r2, [pc, #92]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c12:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8012c16:	6013      	str	r3, [r2, #0]
 8012c18:	4b15      	ldr	r3, [pc, #84]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c1a:	681b      	ldr	r3, [r3, #0]
 8012c1c:	0c5b      	lsrs	r3, r3, #17
 8012c1e:	f003 0301 	and.w	r3, r3, #1
 8012c22:	2b01      	cmp	r3, #1
 8012c24:	d0f2      	beq.n	8012c0c <RCC_DeInit+0x3c>
	
	/* Disable PLL clock source */
	RCC_PLL_DISABLE();
 8012c26:	4b12      	ldr	r3, [pc, #72]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c28:	681b      	ldr	r3, [r3, #0]
 8012c2a:	4a11      	ldr	r2, [pc, #68]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c2c:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8012c30:	6013      	str	r3, [r2, #0]
 8012c32:	4b0f      	ldr	r3, [pc, #60]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c34:	681b      	ldr	r3, [r3, #0]
 8012c36:	0e5b      	lsrs	r3, r3, #25
 8012c38:	f003 0301 	and.w	r3, r3, #1
 8012c3c:	2b01      	cmp	r3, #1
 8012c3e:	d0f2      	beq.n	8012c26 <RCC_DeInit+0x56>

	CLEAR_BIT(RCC->CR, RCC_CR_CSSON);
 8012c40:	4b0b      	ldr	r3, [pc, #44]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c42:	681b      	ldr	r3, [r3, #0]
 8012c44:	4a0a      	ldr	r2, [pc, #40]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c46:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 8012c4a:	6013      	str	r3, [r2, #0]
	
	CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 8012c4c:	4b08      	ldr	r3, [pc, #32]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c4e:	681b      	ldr	r3, [r3, #0]
 8012c50:	4a07      	ldr	r2, [pc, #28]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c52:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8012c56:	6013      	str	r3, [r2, #0]
	
	/* Reset HSITRIM to default value */
	SET_REG(RCC->CR, RCC_CR_HSITRIM, 0x10);
 8012c58:	4b05      	ldr	r3, [pc, #20]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c5a:	681b      	ldr	r3, [r3, #0]
 8012c5c:	4a04      	ldr	r2, [pc, #16]	@ (8012c70 <RCC_DeInit+0xa0>)
 8012c5e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8012c62:	6013      	str	r3, [r2, #0]

	RCC_CIR_Reset();
 8012c64:	f7ff ff3a 	bl	8012adc <RCC_CIR_Reset>
	RCC_PeripheralClock_Reset();
 8012c68:	f7ff ff80 	bl	8012b6c <RCC_PeripheralClock_Reset>
}
 8012c6c:	bf00      	nop
 8012c6e:	bd80      	pop	{r7, pc}
 8012c70:	40021000 	.word	0x40021000

08012c74 <RCC_GetSysClockFreq>:

	CLEAR_REG(RCC->CFGR, RCC_CFGR_PPRE2, 0x7);
	SET_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_ClkInitStruct->APB2CLKDivider);
}

uint32_t RCC_GetSysClockFreq(void) {
 8012c74:	b480      	push	{r7}
 8012c76:	b083      	sub	sp, #12
 8012c78:	af00      	add	r7, sp, #0
	uint32_t sysclk_freq = RCC_HSI_FREQ;
 8012c7a:	4b05      	ldr	r3, [pc, #20]	@ (8012c90 <RCC_GetSysClockFreq+0x1c>)
 8012c7c:	607b      	str	r3, [r7, #4]

	/* Return 8MHz if sysclk source is HSI or HSE */
	if ((READ_REG(RCC->CFGR, RCC_CFGR_SWS, RCC_CFGR_SWS_MASK) & 0x2) == 0) {
 8012c7e:	4b05      	ldr	r3, [pc, #20]	@ (8012c94 <RCC_GetSysClockFreq+0x20>)
 8012c80:	685b      	ldr	r3, [r3, #4]
		return sysclk_freq;
 8012c82:	687b      	ldr	r3, [r7, #4]
	if(mul_factor == RCC_PLL_MUL16_2){
		return sysclk_freq * 16U;
	}

	return sysclk_freq * (2 + mul_factor);
}
 8012c84:	4618      	mov	r0, r3
 8012c86:	370c      	adds	r7, #12
 8012c88:	46bd      	mov	sp, r7
 8012c8a:	bc80      	pop	{r7}
 8012c8c:	4770      	bx	lr
 8012c8e:	bf00      	nop
 8012c90:	007a1200 	.word	0x007a1200
 8012c94:	40021000 	.word	0x40021000

08012c98 <RCC_GetHClockFreq>:

uint32_t RCC_GetHClockFreq(void) {
 8012c98:	b580      	push	{r7, lr}
 8012c9a:	b082      	sub	sp, #8
 8012c9c:	af00      	add	r7, sp, #0
	uint32_t sys_clk 		= RCC_GetSysClockFreq();
 8012c9e:	f7ff ffe9 	bl	8012c74 <RCC_GetSysClockFreq>
 8012ca2:	6078      	str	r0, [r7, #4]
	uint8_t	ahb_div_factor	= READ_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_CFGR_HPRE_MASK);
 8012ca4:	4b10      	ldr	r3, [pc, #64]	@ (8012ce8 <RCC_GetHClockFreq+0x50>)
 8012ca6:	685b      	ldr	r3, [r3, #4]
 8012ca8:	091b      	lsrs	r3, r3, #4
 8012caa:	b2db      	uxtb	r3, r3
 8012cac:	f023 030f 	bic.w	r3, r3, #15
 8012cb0:	70fb      	strb	r3, [r7, #3]
	
	switch (ahb_div_factor)
 8012cb2:	78fb      	ldrb	r3, [r7, #3]
 8012cb4:	2b0b      	cmp	r3, #11
 8012cb6:	dc02      	bgt.n	8012cbe <RCC_GetHClockFreq+0x26>
 8012cb8:	2b08      	cmp	r3, #8
 8012cba:	da04      	bge.n	8012cc6 <RCC_GetHClockFreq+0x2e>
 8012cbc:	e00f      	b.n	8012cde <RCC_GetHClockFreq+0x46>
 8012cbe:	3b0c      	subs	r3, #12
 8012cc0:	2b03      	cmp	r3, #3
 8012cc2:	d80c      	bhi.n	8012cde <RCC_GetHClockFreq+0x46>
 8012cc4:	e005      	b.n	8012cd2 <RCC_GetHClockFreq+0x3a>
	{
		case RCC_SYSCLK_DIV2 ... RCC_SYSCLK_DIV16:
			return sys_clk >> (ahb_div_factor - RCC_SYSCLK_DIV2 + 1);
 8012cc6:	78fb      	ldrb	r3, [r7, #3]
 8012cc8:	3b07      	subs	r3, #7
 8012cca:	687a      	ldr	r2, [r7, #4]
 8012ccc:	fa22 f303 	lsr.w	r3, r2, r3
 8012cd0:	e006      	b.n	8012ce0 <RCC_GetHClockFreq+0x48>
		
		case RCC_SYSCLK_DIV64 ... RCC_SYSCLK_DIV512:
			return sys_clk >> (ahb_div_factor - RCC_SYSCLK_DIV64 + 6);
 8012cd2:	78fb      	ldrb	r3, [r7, #3]
 8012cd4:	3b06      	subs	r3, #6
 8012cd6:	687a      	ldr	r2, [r7, #4]
 8012cd8:	fa22 f303 	lsr.w	r3, r2, r3
 8012cdc:	e000      	b.n	8012ce0 <RCC_GetHClockFreq+0x48>

		default:
			return sys_clk;
 8012cde:	687b      	ldr	r3, [r7, #4]
	}
}
 8012ce0:	4618      	mov	r0, r3
 8012ce2:	3708      	adds	r7, #8
 8012ce4:	46bd      	mov	sp, r7
 8012ce6:	bd80      	pop	{r7, pc}
 8012ce8:	40021000 	.word	0x40021000

08012cec <RCC_GetPClock1Freq>:

uint32_t RCC_GetPClock1Freq(void) {
 8012cec:	b580      	push	{r7, lr}
 8012cee:	b082      	sub	sp, #8
 8012cf0:	af00      	add	r7, sp, #0
	uint32_t hclk 			= RCC_GetHClockFreq();
 8012cf2:	f7ff ffd1 	bl	8012c98 <RCC_GetHClockFreq>
 8012cf6:	6078      	str	r0, [r7, #4]
	uint8_t	apb1_div_factor	= READ_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_MASK);
 8012cf8:	4b09      	ldr	r3, [pc, #36]	@ (8012d20 <RCC_GetPClock1Freq+0x34>)
 8012cfa:	685b      	ldr	r3, [r3, #4]
 8012cfc:	2300      	movs	r3, #0
 8012cfe:	70fb      	strb	r3, [r7, #3]

	switch (apb1_div_factor)
 8012d00:	78fb      	ldrb	r3, [r7, #3]
 8012d02:	3b04      	subs	r3, #4
 8012d04:	2b03      	cmp	r3, #3
 8012d06:	d805      	bhi.n	8012d14 <RCC_GetPClock1Freq+0x28>
	{
		case RCC_HCLK_DIV2 ... RCC_HCLK_DIV16:
			return hclk >> (apb1_div_factor - RCC_HCLK_DIV2 + 1);
 8012d08:	78fb      	ldrb	r3, [r7, #3]
 8012d0a:	3b03      	subs	r3, #3
 8012d0c:	687a      	ldr	r2, [r7, #4]
 8012d0e:	fa22 f303 	lsr.w	r3, r2, r3
 8012d12:	e000      	b.n	8012d16 <RCC_GetPClock1Freq+0x2a>
		
		default:
			return hclk;
 8012d14:	687b      	ldr	r3, [r7, #4]
	}
}
 8012d16:	4618      	mov	r0, r3
 8012d18:	3708      	adds	r7, #8
 8012d1a:	46bd      	mov	sp, r7
 8012d1c:	bd80      	pop	{r7, pc}
 8012d1e:	bf00      	nop
 8012d20:	40021000 	.word	0x40021000

08012d24 <USART_PeriClockControl>:

/*
 * Peripheral clock setup
 */
void USART_PeriClockControl(USART_TypeDef_t *pUSARTx, uint8_t EnorDi)
{
 8012d24:	b480      	push	{r7}
 8012d26:	b083      	sub	sp, #12
 8012d28:	af00      	add	r7, sp, #0
 8012d2a:	6078      	str	r0, [r7, #4]
 8012d2c:	460b      	mov	r3, r1
 8012d2e:	70fb      	strb	r3, [r7, #3]
	if (!EnorDi)
 8012d30:	78fb      	ldrb	r3, [r7, #3]
 8012d32:	2b00      	cmp	r3, #0
 8012d34:	d036      	beq.n	8012da4 <USART_PeriClockControl+0x80>
		return;
	if (pUSARTx == USART1)
 8012d36:	687b      	ldr	r3, [r7, #4]
 8012d38:	4a1d      	ldr	r2, [pc, #116]	@ (8012db0 <USART_PeriClockControl+0x8c>)
 8012d3a:	4293      	cmp	r3, r2
 8012d3c:	d106      	bne.n	8012d4c <USART_PeriClockControl+0x28>
		USART1_PCLK_EN();
 8012d3e:	4b1d      	ldr	r3, [pc, #116]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d40:	699b      	ldr	r3, [r3, #24]
 8012d42:	4a1c      	ldr	r2, [pc, #112]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d44:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8012d48:	6193      	str	r3, [r2, #24]
 8012d4a:	e02c      	b.n	8012da6 <USART_PeriClockControl+0x82>
	else if (pUSARTx == USART2)
 8012d4c:	687b      	ldr	r3, [r7, #4]
 8012d4e:	4a1a      	ldr	r2, [pc, #104]	@ (8012db8 <USART_PeriClockControl+0x94>)
 8012d50:	4293      	cmp	r3, r2
 8012d52:	d106      	bne.n	8012d62 <USART_PeriClockControl+0x3e>
		USART2_PCLK_EN();
 8012d54:	4b17      	ldr	r3, [pc, #92]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d56:	69db      	ldr	r3, [r3, #28]
 8012d58:	4a16      	ldr	r2, [pc, #88]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d5a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8012d5e:	61d3      	str	r3, [r2, #28]
 8012d60:	e021      	b.n	8012da6 <USART_PeriClockControl+0x82>
	else if (pUSARTx == USART3)
 8012d62:	687b      	ldr	r3, [r7, #4]
 8012d64:	4a15      	ldr	r2, [pc, #84]	@ (8012dbc <USART_PeriClockControl+0x98>)
 8012d66:	4293      	cmp	r3, r2
 8012d68:	d106      	bne.n	8012d78 <USART_PeriClockControl+0x54>
		USART3_PCLK_EN();
 8012d6a:	4b12      	ldr	r3, [pc, #72]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d6c:	69db      	ldr	r3, [r3, #28]
 8012d6e:	4a11      	ldr	r2, [pc, #68]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d70:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8012d74:	61d3      	str	r3, [r2, #28]
 8012d76:	e016      	b.n	8012da6 <USART_PeriClockControl+0x82>
	else if (pUSARTx == UART4)
 8012d78:	687b      	ldr	r3, [r7, #4]
 8012d7a:	4a11      	ldr	r2, [pc, #68]	@ (8012dc0 <USART_PeriClockControl+0x9c>)
 8012d7c:	4293      	cmp	r3, r2
 8012d7e:	d106      	bne.n	8012d8e <USART_PeriClockControl+0x6a>
		UART4_PCLK_EN();
 8012d80:	4b0c      	ldr	r3, [pc, #48]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d82:	69db      	ldr	r3, [r3, #28]
 8012d84:	4a0b      	ldr	r2, [pc, #44]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d86:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8012d8a:	61d3      	str	r3, [r2, #28]
 8012d8c:	e00b      	b.n	8012da6 <USART_PeriClockControl+0x82>
	else if (pUSARTx == UART5)
 8012d8e:	687b      	ldr	r3, [r7, #4]
 8012d90:	4a0c      	ldr	r2, [pc, #48]	@ (8012dc4 <USART_PeriClockControl+0xa0>)
 8012d92:	4293      	cmp	r3, r2
 8012d94:	d107      	bne.n	8012da6 <USART_PeriClockControl+0x82>
		UART5_PCLK_EN();
 8012d96:	4b07      	ldr	r3, [pc, #28]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d98:	69db      	ldr	r3, [r3, #28]
 8012d9a:	4a06      	ldr	r2, [pc, #24]	@ (8012db4 <USART_PeriClockControl+0x90>)
 8012d9c:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8012da0:	61d3      	str	r3, [r2, #28]
 8012da2:	e000      	b.n	8012da6 <USART_PeriClockControl+0x82>
		return;
 8012da4:	bf00      	nop
}
 8012da6:	370c      	adds	r7, #12
 8012da8:	46bd      	mov	sp, r7
 8012daa:	bc80      	pop	{r7}
 8012dac:	4770      	bx	lr
 8012dae:	bf00      	nop
 8012db0:	40013800 	.word	0x40013800
 8012db4:	40021000 	.word	0x40021000
 8012db8:	40004400 	.word	0x40004400
 8012dbc:	40004800 	.word	0x40004800
 8012dc0:	40004c00 	.word	0x40004c00
 8012dc4:	40005000 	.word	0x40005000

08012dc8 <USART_Start>:

void USART_Start(USART_TypeDef_t *pUSARTx)
{
 8012dc8:	b480      	push	{r7}
 8012dca:	b083      	sub	sp, #12
 8012dcc:	af00      	add	r7, sp, #0
 8012dce:	6078      	str	r0, [r7, #4]
	pUSARTx->CR1 |= (1 << USART_CR1_UE);
 8012dd0:	687b      	ldr	r3, [r7, #4]
 8012dd2:	68db      	ldr	r3, [r3, #12]
 8012dd4:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
 8012dd8:	687b      	ldr	r3, [r7, #4]
 8012dda:	60da      	str	r2, [r3, #12]
}
 8012ddc:	bf00      	nop
 8012dde:	370c      	adds	r7, #12
 8012de0:	46bd      	mov	sp, r7
 8012de2:	bc80      	pop	{r7}
 8012de4:	4770      	bx	lr
	...

08012de8 <USART_Init>:
/*
 * Init and De-Init
 */

void USART_Init(USART_Handle_t *pUSARTHandle)
{
 8012de8:	b580      	push	{r7, lr}
 8012dea:	b084      	sub	sp, #16
 8012dec:	af00      	add	r7, sp, #0
 8012dee:	6078      	str	r0, [r7, #4]
	// enable clock for USART
	USART_PeriClockControl(pUSARTHandle->pUSARTx, ENABLE);
 8012df0:	687b      	ldr	r3, [r7, #4]
 8012df2:	681b      	ldr	r3, [r3, #0]
 8012df4:	2101      	movs	r1, #1
 8012df6:	4618      	mov	r0, r3
 8012df8:	f7ff ff94 	bl	8012d24 <USART_PeriClockControl>
	uint32_t reg = 0;
 8012dfc:	2300      	movs	r3, #0
 8012dfe:	60fb      	str	r3, [r7, #12]
	// enable USART Tx and Rx engines according to the USART Mode configuration item
	switch (pUSARTHandle->USART_Config.USART_Mode)
 8012e00:	687b      	ldr	r3, [r7, #4]
 8012e02:	791b      	ldrb	r3, [r3, #4]
 8012e04:	2b02      	cmp	r3, #2
 8012e06:	d00f      	beq.n	8012e28 <USART_Init+0x40>
 8012e08:	2b02      	cmp	r3, #2
 8012e0a:	dc12      	bgt.n	8012e32 <USART_Init+0x4a>
 8012e0c:	2b00      	cmp	r3, #0
 8012e0e:	d006      	beq.n	8012e1e <USART_Init+0x36>
 8012e10:	2b01      	cmp	r3, #1
 8012e12:	d10e      	bne.n	8012e32 <USART_Init+0x4a>
	{
	case USART_MODE_ONLY_RX:
		reg |= (1 << USART_CR1_RE);
 8012e14:	68fb      	ldr	r3, [r7, #12]
 8012e16:	f043 0304 	orr.w	r3, r3, #4
 8012e1a:	60fb      	str	r3, [r7, #12]
		break;
 8012e1c:	e009      	b.n	8012e32 <USART_Init+0x4a>
	case USART_MODE_ONLY_TX:
		reg |= (1 << USART_CR1_TE);
 8012e1e:	68fb      	ldr	r3, [r7, #12]
 8012e20:	f043 0308 	orr.w	r3, r3, #8
 8012e24:	60fb      	str	r3, [r7, #12]
		break;
 8012e26:	e004      	b.n	8012e32 <USART_Init+0x4a>
	case USART_MODE_TXRX:
		reg |= (1 << USART_CR1_TE) | (1 << USART_CR1_RE);
 8012e28:	68fb      	ldr	r3, [r7, #12]
 8012e2a:	f043 030c 	orr.w	r3, r3, #12
 8012e2e:	60fb      	str	r3, [r7, #12]
		break;
 8012e30:	bf00      	nop
	default:
	}
	// configure the word length
	reg |= (pUSARTHandle->USART_Config.USART_WordLength << USART_CR1_M);
 8012e32:	687b      	ldr	r3, [r7, #4]
 8012e34:	7b5b      	ldrb	r3, [r3, #13]
 8012e36:	031b      	lsls	r3, r3, #12
 8012e38:	68fa      	ldr	r2, [r7, #12]
 8012e3a:	4313      	orrs	r3, r2
 8012e3c:	60fb      	str	r3, [r7, #12]
	// configure parity bit
	switch (pUSARTHandle->USART_Config.USART_ParityControl)
 8012e3e:	687b      	ldr	r3, [r7, #4]
 8012e40:	7b9b      	ldrb	r3, [r3, #14]
 8012e42:	2b02      	cmp	r3, #2
 8012e44:	d010      	beq.n	8012e68 <USART_Init+0x80>
 8012e46:	2b02      	cmp	r3, #2
 8012e48:	dc13      	bgt.n	8012e72 <USART_Init+0x8a>
 8012e4a:	2b00      	cmp	r3, #0
 8012e4c:	d002      	beq.n	8012e54 <USART_Init+0x6c>
 8012e4e:	2b01      	cmp	r3, #1
 8012e50:	d005      	beq.n	8012e5e <USART_Init+0x76>
 8012e52:	e00e      	b.n	8012e72 <USART_Init+0x8a>
	{
	case USART_PARITY_DISABLE:
		reg &= ~(1 << USART_CR1_PCE);
 8012e54:	68fb      	ldr	r3, [r7, #12]
 8012e56:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8012e5a:	60fb      	str	r3, [r7, #12]
		break;
 8012e5c:	e009      	b.n	8012e72 <USART_Init+0x8a>
	case USART_PARITY_EN_EVEN:
		reg |= (1 << USART_CR1_PCE);
 8012e5e:	68fb      	ldr	r3, [r7, #12]
 8012e60:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8012e64:	60fb      	str	r3, [r7, #12]
		break;
 8012e66:	e004      	b.n	8012e72 <USART_Init+0x8a>
	case USART_PARITY_EN_ODD:
		reg |= (1 << USART_CR1_PCE) | (1 << USART_CR1_PS);
 8012e68:	68fb      	ldr	r3, [r7, #12]
 8012e6a:	f443 63c0 	orr.w	r3, r3, #1536	@ 0x600
 8012e6e:	60fb      	str	r3, [r7, #12]
		break;
 8012e70:	bf00      	nop
	default:
	}

	pUSARTHandle->pUSARTx->CR1 = reg;
 8012e72:	687b      	ldr	r3, [r7, #4]
 8012e74:	681b      	ldr	r3, [r3, #0]
 8012e76:	68fa      	ldr	r2, [r7, #12]
 8012e78:	60da      	str	r2, [r3, #12]

	reg = 0;
 8012e7a:	2300      	movs	r3, #0
 8012e7c:	60fb      	str	r3, [r7, #12]
	// configure the number of stop bit
	reg |= (pUSARTHandle->USART_Config.USART_NumberOfStopBits << USART_CR2_STOP);
 8012e7e:	687b      	ldr	r3, [r7, #4]
 8012e80:	7b1b      	ldrb	r3, [r3, #12]
 8012e82:	031b      	lsls	r3, r3, #12
 8012e84:	68fa      	ldr	r2, [r7, #12]
 8012e86:	4313      	orrs	r3, r2
 8012e88:	60fb      	str	r3, [r7, #12]

	pUSARTHandle->pUSARTx->CR2 = reg;
 8012e8a:	687b      	ldr	r3, [r7, #4]
 8012e8c:	681b      	ldr	r3, [r3, #0]
 8012e8e:	68fa      	ldr	r2, [r7, #12]
 8012e90:	611a      	str	r2, [r3, #16]

	reg = 0;
 8012e92:	2300      	movs	r3, #0
 8012e94:	60fb      	str	r3, [r7, #12]

	// configure hardware flow control
	switch (pUSARTHandle->USART_Config.USART_HWFLowControl)
 8012e96:	687b      	ldr	r3, [r7, #4]
 8012e98:	7bdb      	ldrb	r3, [r3, #15]
 8012e9a:	2b03      	cmp	r3, #3
 8012e9c:	d826      	bhi.n	8012eec <USART_Init+0x104>
 8012e9e:	a201      	add	r2, pc, #4	@ (adr r2, 8012ea4 <USART_Init+0xbc>)
 8012ea0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012ea4:	08012eb5 	.word	0x08012eb5
 8012ea8:	08012ec7 	.word	0x08012ec7
 8012eac:	08012ed1 	.word	0x08012ed1
 8012eb0:	08012edb 	.word	0x08012edb
	{
	case USART_HW_FLOW_CTRL_NONE:
		reg &= ~(1 << USART_CR3_CTSE);
 8012eb4:	68fb      	ldr	r3, [r7, #12]
 8012eb6:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8012eba:	60fb      	str	r3, [r7, #12]
		reg &= ~(1 << USART_CR3_RTSE);
 8012ebc:	68fb      	ldr	r3, [r7, #12]
 8012ebe:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8012ec2:	60fb      	str	r3, [r7, #12]
		break;
 8012ec4:	e012      	b.n	8012eec <USART_Init+0x104>
	case USART_HW_FLOW_CTRL_CTS:
		reg |= (1 << USART_CR3_CTSE);
 8012ec6:	68fb      	ldr	r3, [r7, #12]
 8012ec8:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8012ecc:	60fb      	str	r3, [r7, #12]
		break;
 8012ece:	e00d      	b.n	8012eec <USART_Init+0x104>
	case USART_HW_FLOW_CTRL_RTS:
		reg |= (1 << USART_CR3_RTSE);
 8012ed0:	68fb      	ldr	r3, [r7, #12]
 8012ed2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8012ed6:	60fb      	str	r3, [r7, #12]
		break;
 8012ed8:	e008      	b.n	8012eec <USART_Init+0x104>
	case USART_HW_FLOW_CTRL_CTS_RTS:
		reg |= (1 << USART_CR3_CTSE);
 8012eda:	68fb      	ldr	r3, [r7, #12]
 8012edc:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8012ee0:	60fb      	str	r3, [r7, #12]
		reg |= (1 << USART_CR3_RTSE);
 8012ee2:	68fb      	ldr	r3, [r7, #12]
 8012ee4:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8012ee8:	60fb      	str	r3, [r7, #12]
		break;
 8012eea:	bf00      	nop
	default:
	}
	pUSARTHandle->pUSARTx->CR3 = reg;
 8012eec:	687b      	ldr	r3, [r7, #4]
 8012eee:	681b      	ldr	r3, [r3, #0]
 8012ef0:	68fa      	ldr	r2, [r7, #12]
 8012ef2:	615a      	str	r2, [r3, #20]

	// Implement the code to configure the baud rate
	// We will cover this in the lecture. No action required here
	USART_SetBaudRate(pUSARTHandle->pUSARTx, pUSARTHandle->USART_Config.USART_Baudrate);
 8012ef4:	687b      	ldr	r3, [r7, #4]
 8012ef6:	681a      	ldr	r2, [r3, #0]
 8012ef8:	687b      	ldr	r3, [r7, #4]
 8012efa:	689b      	ldr	r3, [r3, #8]
 8012efc:	4619      	mov	r1, r3
 8012efe:	4610      	mov	r0, r2
 8012f00:	f000 f804 	bl	8012f0c <USART_SetBaudRate>
}
 8012f04:	bf00      	nop
 8012f06:	3710      	adds	r7, #16
 8012f08:	46bd      	mov	sp, r7
 8012f0a:	bd80      	pop	{r7, pc}

08012f0c <USART_SetBaudRate>:

void USART_SetBaudRate(USART_TypeDef_t *pUSARTx, uint32_t BaudRate)
{
 8012f0c:	b580      	push	{r7, lr}
 8012f0e:	b088      	sub	sp, #32
 8012f10:	af00      	add	r7, sp, #0
 8012f12:	6078      	str	r0, [r7, #4]
 8012f14:	6039      	str	r1, [r7, #0]
	uint32_t PCLKx;

	uint32_t usartdiv;

	uint32_t M_part, F_part;
	uint32_t reg = 0;
 8012f16:	2300      	movs	r3, #0
 8012f18:	61bb      	str	r3, [r7, #24]

	if(pUSARTx == USART1) PCLKx = RCC_GetPClock1Freq();
 8012f1a:	687b      	ldr	r3, [r7, #4]
 8012f1c:	4a1f      	ldr	r2, [pc, #124]	@ (8012f9c <USART_SetBaudRate+0x90>)
 8012f1e:	4293      	cmp	r3, r2
 8012f20:	d103      	bne.n	8012f2a <USART_SetBaudRate+0x1e>
 8012f22:	f7ff fee3 	bl	8012cec <RCC_GetPClock1Freq>
 8012f26:	61f8      	str	r0, [r7, #28]
 8012f28:	e002      	b.n	8012f30 <USART_SetBaudRate+0x24>
	else PCLKx = RCC_GetPClock1Freq();
 8012f2a:	f7ff fedf 	bl	8012cec <RCC_GetPClock1Freq>
 8012f2e:	61f8      	str	r0, [r7, #28]

	usartdiv = (25 * PCLKx) / (4 * BaudRate);
 8012f30:	69fa      	ldr	r2, [r7, #28]
 8012f32:	4613      	mov	r3, r2
 8012f34:	009b      	lsls	r3, r3, #2
 8012f36:	4413      	add	r3, r2
 8012f38:	009a      	lsls	r2, r3, #2
 8012f3a:	441a      	add	r2, r3
 8012f3c:	683b      	ldr	r3, [r7, #0]
 8012f3e:	009b      	lsls	r3, r3, #2
 8012f40:	fbb2 f3f3 	udiv	r3, r2, r3
 8012f44:	617b      	str	r3, [r7, #20]

	M_part = usartdiv / 100;
 8012f46:	697b      	ldr	r3, [r7, #20]
 8012f48:	4a15      	ldr	r2, [pc, #84]	@ (8012fa0 <USART_SetBaudRate+0x94>)
 8012f4a:	fba2 2303 	umull	r2, r3, r2, r3
 8012f4e:	095b      	lsrs	r3, r3, #5
 8012f50:	613b      	str	r3, [r7, #16]
	reg |= M_part << 4;
 8012f52:	693b      	ldr	r3, [r7, #16]
 8012f54:	011b      	lsls	r3, r3, #4
 8012f56:	69ba      	ldr	r2, [r7, #24]
 8012f58:	4313      	orrs	r3, r2
 8012f5a:	61bb      	str	r3, [r7, #24]

	F_part = usartdiv % 100;
 8012f5c:	697b      	ldr	r3, [r7, #20]
 8012f5e:	4a10      	ldr	r2, [pc, #64]	@ (8012fa0 <USART_SetBaudRate+0x94>)
 8012f60:	fba2 1203 	umull	r1, r2, r2, r3
 8012f64:	0952      	lsrs	r2, r2, #5
 8012f66:	2164      	movs	r1, #100	@ 0x64
 8012f68:	fb01 f202 	mul.w	r2, r1, r2
 8012f6c:	1a9b      	subs	r3, r3, r2
 8012f6e:	60fb      	str	r3, [r7, #12]

	F_part = (((F_part * 16) + 50) / 100) & 0x0F;
 8012f70:	68fb      	ldr	r3, [r7, #12]
 8012f72:	011b      	lsls	r3, r3, #4
 8012f74:	3332      	adds	r3, #50	@ 0x32
 8012f76:	4a0a      	ldr	r2, [pc, #40]	@ (8012fa0 <USART_SetBaudRate+0x94>)
 8012f78:	fba2 2303 	umull	r2, r3, r2, r3
 8012f7c:	095b      	lsrs	r3, r3, #5
 8012f7e:	f003 030f 	and.w	r3, r3, #15
 8012f82:	60fb      	str	r3, [r7, #12]

	reg |= F_part;
 8012f84:	69ba      	ldr	r2, [r7, #24]
 8012f86:	68fb      	ldr	r3, [r7, #12]
 8012f88:	4313      	orrs	r3, r2
 8012f8a:	61bb      	str	r3, [r7, #24]

	pUSARTx->BRR = reg;
 8012f8c:	687b      	ldr	r3, [r7, #4]
 8012f8e:	69ba      	ldr	r2, [r7, #24]
 8012f90:	609a      	str	r2, [r3, #8]
}
 8012f92:	bf00      	nop
 8012f94:	3720      	adds	r7, #32
 8012f96:	46bd      	mov	sp, r7
 8012f98:	bd80      	pop	{r7, pc}
 8012f9a:	bf00      	nop
 8012f9c:	40013800 	.word	0x40013800
 8012fa0:	51eb851f 	.word	0x51eb851f

08012fa4 <USART_SendData>:
/*
 * Data send and Receive
 */

void USART_SendData(USART_Handle_t *pUSARTHandle, uint8_t *pTxBuffer, uint32_t length)
{
 8012fa4:	b480      	push	{r7}
 8012fa6:	b085      	sub	sp, #20
 8012fa8:	af00      	add	r7, sp, #0
 8012faa:	60f8      	str	r0, [r7, #12]
 8012fac:	60b9      	str	r1, [r7, #8]
 8012fae:	607a      	str	r2, [r7, #4]
	while (length > 0)
 8012fb0:	e030      	b.n	8013014 <USART_SendData+0x70>
	{
		// wait until TXE flag is set in the SR
		while (!((pUSARTHandle->pUSARTx->SR >> USART_SR_TXE) & 1))
 8012fb2:	bf00      	nop
 8012fb4:	68fb      	ldr	r3, [r7, #12]
 8012fb6:	681b      	ldr	r3, [r3, #0]
 8012fb8:	681b      	ldr	r3, [r3, #0]
 8012fba:	09db      	lsrs	r3, r3, #7
 8012fbc:	f003 0301 	and.w	r3, r3, #1
 8012fc0:	2b00      	cmp	r3, #0
 8012fc2:	d0f7      	beq.n	8012fb4 <USART_SendData+0x10>
			;

		// Check the USART_WordLength
		if (pUSARTHandle->USART_Config.USART_WordLength == USART_WORDLEN_9BITS)
 8012fc4:	68fb      	ldr	r3, [r7, #12]
 8012fc6:	7b5b      	ldrb	r3, [r3, #13]
 8012fc8:	2b01      	cmp	r3, #1
 8012fca:	d118      	bne.n	8012ffe <USART_SendData+0x5a>
		{
			// check for USART_ParityControl
			if (pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_DISABLE)
 8012fcc:	68fb      	ldr	r3, [r7, #12]
 8012fce:	7b9b      	ldrb	r3, [r3, #14]
 8012fd0:	2b00      	cmp	r3, #0
 8012fd2:	d10b      	bne.n	8012fec <USART_SendData+0x48>
			{
				pUSARTHandle->pUSARTx->DR = (*((uint16_t *)pTxBuffer) & (uint16_t)0x01FF);
 8012fd4:	68bb      	ldr	r3, [r7, #8]
 8012fd6:	881b      	ldrh	r3, [r3, #0]
 8012fd8:	461a      	mov	r2, r3
 8012fda:	68fb      	ldr	r3, [r7, #12]
 8012fdc:	681b      	ldr	r3, [r3, #0]
 8012fde:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8012fe2:	605a      	str	r2, [r3, #4]
				// 9 bits of user data will be sent
				(uint16_t *)pTxBuffer++;
 8012fe4:	68bb      	ldr	r3, [r7, #8]
 8012fe6:	3301      	adds	r3, #1
 8012fe8:	60bb      	str	r3, [r7, #8]
 8012fea:	e010      	b.n	801300e <USART_SendData+0x6a>
			}
			else
			{
				pUSARTHandle->pUSARTx->DR = (*(pTxBuffer) & (uint8_t)0xFF);
 8012fec:	68bb      	ldr	r3, [r7, #8]
 8012fee:	781a      	ldrb	r2, [r3, #0]
 8012ff0:	68fb      	ldr	r3, [r7, #12]
 8012ff2:	681b      	ldr	r3, [r3, #0]
 8012ff4:	605a      	str	r2, [r3, #4]
				// Parity bit is used in this transfer . so 8bits of user data will be sent
				pTxBuffer++;
 8012ff6:	68bb      	ldr	r3, [r7, #8]
 8012ff8:	3301      	adds	r3, #1
 8012ffa:	60bb      	str	r3, [r7, #8]
 8012ffc:	e007      	b.n	801300e <USART_SendData+0x6a>
			}
		}
		else
		{
			// This is 8bit data transfer
			pUSARTHandle->pUSARTx->DR = (*(pTxBuffer) & (uint8_t)0xFF);
 8012ffe:	68bb      	ldr	r3, [r7, #8]
 8013000:	781a      	ldrb	r2, [r3, #0]
 8013002:	68fb      	ldr	r3, [r7, #12]
 8013004:	681b      	ldr	r3, [r3, #0]
 8013006:	605a      	str	r2, [r3, #4]

			// increment the transmit buffer address by 1
			pTxBuffer++;
 8013008:	68bb      	ldr	r3, [r7, #8]
 801300a:	3301      	adds	r3, #1
 801300c:	60bb      	str	r3, [r7, #8]
		}
		length--;
 801300e:	687b      	ldr	r3, [r7, #4]
 8013010:	3b01      	subs	r3, #1
 8013012:	607b      	str	r3, [r7, #4]
	while (length > 0)
 8013014:	687b      	ldr	r3, [r7, #4]
 8013016:	2b00      	cmp	r3, #0
 8013018:	d1cb      	bne.n	8012fb2 <USART_SendData+0xe>
	}
	// wailt till TC flag is set in the SR
	while (!((pUSARTHandle->pUSARTx->SR >> USART_SR_TC) & 1))
 801301a:	bf00      	nop
 801301c:	68fb      	ldr	r3, [r7, #12]
 801301e:	681b      	ldr	r3, [r3, #0]
 8013020:	681b      	ldr	r3, [r3, #0]
 8013022:	099b      	lsrs	r3, r3, #6
 8013024:	f003 0301 	and.w	r3, r3, #1
 8013028:	2b00      	cmp	r3, #0
 801302a:	d0f7      	beq.n	801301c <USART_SendData+0x78>
		;
}
 801302c:	bf00      	nop
 801302e:	bf00      	nop
 8013030:	3714      	adds	r7, #20
 8013032:	46bd      	mov	sp, r7
 8013034:	bc80      	pop	{r7}
 8013036:	4770      	bx	lr

08013038 <USART_ReceiveDataIT>:
	}
	return state;
}

uint8_t USART_ReceiveDataIT(USART_Handle_t *pUSARTHandle, uint8_t *pRxBuffer, uint32_t length)
{
 8013038:	b480      	push	{r7}
 801303a:	b087      	sub	sp, #28
 801303c:	af00      	add	r7, sp, #0
 801303e:	60f8      	str	r0, [r7, #12]
 8013040:	60b9      	str	r1, [r7, #8]
 8013042:	607a      	str	r2, [r7, #4]
	uint8_t state = pUSARTHandle->RxState;
 8013044:	68fb      	ldr	r3, [r7, #12]
 8013046:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 801304a:	75fb      	strb	r3, [r7, #23]
	if (state != USART_BUSY_RX)
 801304c:	7dfb      	ldrb	r3, [r7, #23]
 801304e:	2b01      	cmp	r3, #1
 8013050:	d011      	beq.n	8013076 <USART_ReceiveDataIT+0x3e>
	{
		pUSARTHandle->pRxBuffer = pRxBuffer;
 8013052:	68fb      	ldr	r3, [r7, #12]
 8013054:	68ba      	ldr	r2, [r7, #8]
 8013056:	615a      	str	r2, [r3, #20]
		pUSARTHandle->RxLength = length;
 8013058:	68fb      	ldr	r3, [r7, #12]
 801305a:	687a      	ldr	r2, [r7, #4]
 801305c:	61da      	str	r2, [r3, #28]

		pUSARTHandle->RxState = USART_BUSY_RX;
 801305e:	68fb      	ldr	r3, [r7, #12]
 8013060:	2201      	movs	r2, #1
 8013062:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21

		pUSARTHandle->pUSARTx->CR1 |= (1 << USART_CR1_RXNEIE);
 8013066:	68fb      	ldr	r3, [r7, #12]
 8013068:	681b      	ldr	r3, [r3, #0]
 801306a:	68da      	ldr	r2, [r3, #12]
 801306c:	68fb      	ldr	r3, [r7, #12]
 801306e:	681b      	ldr	r3, [r3, #0]
 8013070:	f042 0220 	orr.w	r2, r2, #32
 8013074:	60da      	str	r2, [r3, #12]
	}
	return state;
 8013076:	7dfb      	ldrb	r3, [r7, #23]
}
 8013078:	4618      	mov	r0, r3
 801307a:	371c      	adds	r7, #28
 801307c:	46bd      	mov	sp, r7
 801307e:	bc80      	pop	{r7}
 8013080:	4770      	bx	lr
	...

08013084 <__libc_init_array>:
 8013084:	b570      	push	{r4, r5, r6, lr}
 8013086:	2600      	movs	r6, #0
 8013088:	4d0c      	ldr	r5, [pc, #48]	@ (80130bc <__libc_init_array+0x38>)
 801308a:	4c0d      	ldr	r4, [pc, #52]	@ (80130c0 <__libc_init_array+0x3c>)
 801308c:	1b64      	subs	r4, r4, r5
 801308e:	10a4      	asrs	r4, r4, #2
 8013090:	42a6      	cmp	r6, r4
 8013092:	d109      	bne.n	80130a8 <__libc_init_array+0x24>
 8013094:	f000 f81a 	bl	80130cc <_init>
 8013098:	2600      	movs	r6, #0
 801309a:	4d0a      	ldr	r5, [pc, #40]	@ (80130c4 <__libc_init_array+0x40>)
 801309c:	4c0a      	ldr	r4, [pc, #40]	@ (80130c8 <__libc_init_array+0x44>)
 801309e:	1b64      	subs	r4, r4, r5
 80130a0:	10a4      	asrs	r4, r4, #2
 80130a2:	42a6      	cmp	r6, r4
 80130a4:	d105      	bne.n	80130b2 <__libc_init_array+0x2e>
 80130a6:	bd70      	pop	{r4, r5, r6, pc}
 80130a8:	f855 3b04 	ldr.w	r3, [r5], #4
 80130ac:	4798      	blx	r3
 80130ae:	3601      	adds	r6, #1
 80130b0:	e7ee      	b.n	8013090 <__libc_init_array+0xc>
 80130b2:	f855 3b04 	ldr.w	r3, [r5], #4
 80130b6:	4798      	blx	r3
 80130b8:	3601      	adds	r6, #1
 80130ba:	e7f2      	b.n	80130a2 <__libc_init_array+0x1e>
 80130bc:	08013108 	.word	0x08013108
 80130c0:	08013108 	.word	0x08013108
 80130c4:	08013108 	.word	0x08013108
 80130c8:	0801310c 	.word	0x0801310c

080130cc <_init>:
 80130cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80130ce:	bf00      	nop
 80130d0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80130d2:	bc08      	pop	{r3}
 80130d4:	469e      	mov	lr, r3
 80130d6:	4770      	bx	lr

080130d8 <_fini>:
 80130d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80130da:	bf00      	nop
 80130dc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80130de:	bc08      	pop	{r3}
 80130e0:	469e      	mov	lr, r3
 80130e2:	4770      	bx	lr
