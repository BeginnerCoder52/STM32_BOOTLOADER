#include "bootloader.h"
#include "flash_if.h"
#include "bl_meta.h"
#include "stm32f103xx.h"


uint32_t crc32_calc(const uint8_t* p, uint32_t n) {
    uint32_t crc = 0xFFFFFFFF;
    for (uint32_t i = 0; i < n; i++) {
        crc ^= p[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 1) crc = (crc >> 1) ^ 0xEDB88320;
            else crc >>= 1;
        }
    }
    return ~crc;
}

static void copy_partition(part_t src, part_t dst) {
    // Implementation can be added later if needed
}

static int is_partition_valid(part_t p) {
    app_footer_t f;
    uint32_t footer_addr = (p == PART_CURRENT) ? CUR_FOOTER_ADDR : OLD_FOOTER_ADDR;
    read_footer(footer_addr, &f);
    if (f.magic != FOOTER_MAGIC || f.valid == 0) return 0; // Invalid
    return 1;
}

static uint32_t part_base(part_t p) {
    return (p == PART_CURRENT) ? CUR_START : OLD_START;
}

static void jump_to_app(part_t p) {
    uint32_t app_addr = part_base(p);
    uint32_t sp = *(volatile uint32_t*)(app_addr);
    uint32_t rv = *(volatile uint32_t*)(app_addr + 4);

    RCC_DeInit(); // From stm32f103xx_rcc_driver.h
    __asm volatile ("MSR MSP, %0" : : "r" (sp)); // Manual MSP setup

    ((void (*)(void))rv)(); // Jump into app
}

void bootloader_main(void) {
    boot_ctrl_t bcb;
    read_bcb(&bcb);

    if (bcb.magic != BCB_MAGIC) {
        bcb.magic = BCB_MAGIC;
        bcb.pending = 0;
        bcb.boot_target = PART_CURRENT;
        bcb.trial_count = 0;
        flash_erase_range(BCB_ADDR, PAGE_SIZE);
        flash_write(BCB_ADDR, (uint8_t*)&bcb, sizeof(bcb));
    }

    part_t target = bcb.pending ? (part_t)bcb.boot_target : PART_CURRENT;
    if (is_partition_valid(target)) {
        jump_to_app(target);
    } else if (bcb.trial_count > 0) {
        bcb.trial_count--;
        write_bcb(&bcb);
        jump_to_app(PART_CURRENT);
    } else {
        uint8_t buf[CHUNK_SIZE + 1];
        uint32_t fw_size, fw_crc;
        USART_Handle_t usart1 = {USART1, {0}};
        USART_ReceiveDataIT(&usart1, (uint8_t*)&fw_size, sizeof(fw_size));
        USART_ReceiveDataIT(&usart1, (uint8_t*)&fw_crc, sizeof(fw_crc));

        flash_erase_range(CUR_START, CUR_SIZE - PAGE_SIZE);
        uint32_t addr = CUR_START;
        uint32_t received_crc = 0xFFFFFFFF;
        for (uint32_t i = 0; i < fw_size; i += CHUNK_SIZE) {
            uint32_t len = (fw_size - i < CHUNK_SIZE) ? (fw_size - i) : CHUNK_SIZE;
            USART_ReceiveDataIT(&usart1, buf, len + 1);
            uint8_t chunk_cs = 0;
            for (uint32_t j = 0; j < len; j++) chunk_cs ^= buf[j];
            if (chunk_cs != buf[len]) {
                uint8_t err = 'E';
                USART_SendDataIT(&usart1, &err, 1);
                return;
            }
            for (uint32_t j = 0; j < len; j++) received_crc = crc32_calc(&buf[j], 1);
            if (flash_write(addr, buf, len) == -1) {
                uint8_t err = 'E';
                USART_SendDataIT(&usart1, &err, 1);
                flash_erase_range(CUR_START, CUR_SIZE);
                return;
            }
            uint8_t ack = 'A';
            USART_SendDataIT(&usart1, &ack, 1);
            addr += len;
        }
        received_crc = ~received_crc;
        if (received_crc != fw_crc) {
            uint8_t err = 'E';
            USART_SendDataIT(&usart1, &err, 1);
            return;
        }
        app_footer_t footer = {FOOTER_MAGIC, 1, fw_size, fw_crc, 0x00010000};
        write_footer(CUR_FOOTER_ADDR, &footer);
        bcb.pending = 1;
        bcb.boot_target = PART_CURRENT;
        bcb.trial_count = 3;
        write_bcb(&bcb);
    }
}
