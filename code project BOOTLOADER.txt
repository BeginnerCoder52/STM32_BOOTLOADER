=========
bl_meta.h

#pragma once
#include <stdint.h>

#define FLASH_BASE_ADDR   0x08000000u
#define PAGE_SIZE         1024u

#define BL_START          0x08000000u
#define BL_SIZE           (16u*1024u)
#define BCB_ADDR          (BL_START + BL_SIZE - PAGE_SIZE)

#define CUR_START         0x08004000u
#define CUR_SIZE          (56u*1024u)
#define CUR_FOOTER_ADDR   (CUR_START + CUR_SIZE - PAGE_SIZE)

#define OLD_START         0x08012000u
#define OLD_SIZE          (56u*1024u)
#define OLD_FOOTER_ADDR   (OLD_START + OLD_SIZE - PAGE_SIZE)

#define FOOTER_MAGIC 0x5A5A55AAu
#define BCB_MAGIC    0x424C424Cu

typedef struct __attribute__((packed)) {
  uint32_t magic;     // FOOTER_MAGIC
  uint32_t valid;     // 1 = d� verify OK
  uint32_t size;      // s? byte image d� ghi
  uint32_t crc32;     // CRC32 c?a image
  uint32_t version;   // v� d? 0x00030000
} app_footer_t;

typedef enum { PART_CURRENT=0, PART_OLD=1 } part_t;

typedef struct __attribute__((packed)) {
  uint32_t magic;        // BCB_MAGIC
  uint32_t boot_target;  // PART_CURRENT ho?c PART_OLD
  uint32_t pending;      // 1 = c� update ch? boot th?
  uint32_t trial_count;  // s? l?n boot th? c�n l?i
} boot_ctrl_t;

=========
flash_if.h

#ifndef __FLASH_IF_H
#define __FLASH_IF_H

#include <stdint.h>
#include "bl_meta.h"

#ifdef __cplusplus
extern "C" {
#endif

void flash_unlock(void);
void flash_lock(void);
int flash_erase_range(uint32_t addr, uint32_t len);
int flash_write(uint32_t addr, const uint8_t* data, uint32_t len);

uint32_t crc32_calc(const uint8_t* p, uint32_t n);

void read_bcb(boot_ctrl_t* b);
void write_bcb(const boot_ctrl_t* b);
void read_footer(uint32_t addr, app_footer_t* f);
void write_footer(uint32_t addr, const app_footer_t* f);

#ifdef __cplusplus
}
#endif

#endif /* __FLASH_IF_H */

=========
bootloader.h

#ifndef __BOOTLOADER_H
#define __BOOTLOADER_H

#ifdef __cplusplus
extern "C" {
#endif

#include "stm32f1xx_hal.h"
#include <stdint.h>
#include <stdbool.h>
#include "bl_meta.h"     // File n�y ch?a d?nh nghia d?a ch? v�ng nh?, struct metadata
#include "flash_if.h"    // File n�y ch?a h�m ghi/xo� flash

// ====== �?nh nghia enum ph�n v�ng ======
//typedef enum {
//    PART_CURRENT = 0,
//    PART_OLD     = 1
//} part_t;
// da co o bl_meta.h

// ====== H�m ch�nh c?a bootloader ======
void bootloader_main(void);

// ====== H�m OTA (n?p firmware qua UART/SPI) ======
void ota_receive_loop(void);

#ifdef __cplusplus
}
#endif

#endif /* __BOOTLOADER_H */

=========
flash_if.c

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "bl_meta.h"
#include "stm32f1xx_hal.h"
#include "flash_if.h"

void flash_unlock(void){ HAL_FLASH_Unlock(); }
void flash_lock(void){ HAL_FLASH_Lock(); }

int flash_erase_range(uint32_t addr, uint32_t len){
    FLASH_EraseInitTypeDef e={0}; uint32_t err;
    flash_unlock();
    for(uint32_t a=addr; a<addr+len; a+=PAGE_SIZE){
        e.TypeErase=FLASH_TYPEERASE_PAGES; e.PageAddress=a; e.NbPages=1;
        if(HAL_FLASHEx_Erase(&e,&err)!=HAL_OK){ flash_lock(); return -1; }
    }
    flash_lock(); return 0;
}

int flash_write(uint32_t addr, const uint8_t* data, uint32_t len){
    flash_unlock();
		uint8_t verify_buf[2];
    for(uint32_t i=0;i<len;i+=2){
        uint16_t hw = data[i] | ((i+1<len?data[i+1]:0)<<8);
        if(HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, addr+i, hw)!=HAL_OK){
            flash_lock(); return -1;
        }
				memcpy(verify_buf, (void*)(addr + i), 2);
				if(verify_buf[0] != data[i] || (i+1<len && verify_buf[1] != data[i+1])) return -1;
    }
    flash_lock(); return 0;
}

uint32_t crc32_update(uint32_t crc, uint8_t d){
    crc^=d;
    for(int i=0;i<8;i++)
        crc = (crc&1)? (crc>>1)^0xEDB88320u : (crc>>1);
    return crc;
}

uint32_t crc32_calc(const uint8_t* p, uint32_t n){
    uint32_t crc=0xFFFFFFFFu;
    for(uint32_t i=0;i<n;i++) crc=crc32_update(crc,p[i]);
    return ~crc;
}

void read_bcb(boot_ctrl_t* b){ memcpy(b,(void*)BCB_ADDR,sizeof(*b)); }
void write_bcb(const boot_ctrl_t* b){
    flash_erase_range(BCB_ADDR, PAGE_SIZE);
    flash_write(BCB_ADDR, (const uint8_t*)b, sizeof(*b));
}

void read_footer(uint32_t addr, app_footer_t* f){
    memcpy(f,(void*)addr,sizeof(*f));
}

void write_footer(uint32_t addr, const app_footer_t* f){
    flash_erase_range(addr, PAGE_SIZE);
    flash_write(addr, (const uint8_t*)f, sizeof(*f));
}


=========
#include "bootloader.h"
#include "flash_if.h"
#include "bl_meta.h"
#include "stm32f1xx_hal.h"
#include <string.h>
#include "stm32f1xx_hal_uart.h"

extern UART_HandleTypeDef huart1;
uint32_t crc32_update(uint32_t crc, uint8_t d);
static void copy_partition(part_t src, part_t dst);

//======= FUNCTION TO CHECK IF PARTITION IS VALID =======
static int is_partition_valid(part_t p) {
    app_footer_t f;
    uint32_t footer_addr = (p==PART_CURRENT)?CUR_FOOTER_ADDR:OLD_FOOTER_ADDR;
    memcpy(&f, (void*)footer_addr, sizeof(f));
    if(f.magic != FOOTER_MAGIC || f.valid == 0) return 0; // Invalid
    return 1;
}

// ======= FUNCTION TO JUMP TO APP =======
typedef void (*pFunction)(void);
static uint32_t part_base(part_t p) {
    return (p==PART_CURRENT)?CUR_START:OLD_START;
}
static void jump_to_app(part_t p) {
    uint32_t app_addr = part_base(p);
    uint32_t sp = *(volatile uint32_t*)(app_addr);
    uint32_t rv = *(volatile uint32_t*)(app_addr+4);

    HAL_RCC_DeInit();
    HAL_DeInit();
    SysTick->CTRL = 0;

    __disable_irq();
    __set_MSP(sp);
    SCB->VTOR = app_addr;
    __enable_irq();

    ((pFunction)rv)(); // Jump into app
}

// ======= MAIN BOOTLOADER FUNCTION =======
void bootloader_main(void) {
    boot_ctrl_t bcb;
    memcpy(&bcb, (void*)BCB_ADDR, sizeof(bcb));

    if(bcb.magic != BCB_MAGIC) {
        bcb.magic = BCB_MAGIC;
        bcb.pending = 0;
        bcb.boot_target = PART_CURRENT;
        bcb.trial_count = 0;
        flash_erase_range(BCB_ADDR, PAGE_SIZE);
        flash_write(BCB_ADDR, (uint8_t*)&bcb, sizeof(bcb));
    }

    part_t target = bcb.pending ? (part_t)bcb.boot_target : PART_CURRENT;

    if(is_partition_valid(target)) {
        if(bcb.pending && bcb.trial_count > 0) {
            bcb.trial_count--;
            flash_erase_range(BCB_ADDR, PAGE_SIZE);
            flash_write(BCB_ADDR, (uint8_t*)&bcb, sizeof(bcb));
        }
        jump_to_app(target);
    }
		
		if (bcb.pending && bcb.trial_count == 0) {
				bcb.pending = 0;
				bcb.boot_target = PART_OLD;  // Assume failure on CURRENT, fallback to OLD
				write_bcb(&bcb);
		}
		
    part_t other = (target==PART_CURRENT)?PART_OLD:PART_CURRENT;
    if(is_partition_valid(other)) {
        bcb.pending = 0;
        bcb.trial_count = 0;
        bcb.boot_target = other;
        flash_erase_range(BCB_ADDR, PAGE_SIZE);
        flash_write(BCB_ADDR, (uint8_t*)&bcb, sizeof(bcb));
        jump_to_app(other);
    }

    // If both apps are invalid, wait for OTA from ESP32
    while(1) {
        ota_receive_loop(); 
    }
}

void ota_receive_loop(void) {
	uint8_t cmd;
	uint32_t fw_size, fw_crc;
	uint8_t buf[CHUNK_SIZE + 1];  // +1 for chunk checksum
	while(1) {
			HAL_UART_Receive(&huart1, &cmd, 1, HAL_MAX_DELAY);
			if(cmd != FW_REQUEST) continue;
			HAL_UART_Receive(&huart1, (uint8_t*)&fw_size, 4, HAL_MAX_DELAY);
			HAL_UART_Receive(&huart1, (uint8_t*)&fw_crc, 4, HAL_MAX_DELAY);
			if(fw_size > MAX_FW_SIZE) {
					uint8_t err = FW_ERR;
					HAL_UART_Transmit(&huart1, &err, 1, HAL_MAX_DELAY);
					continue;  // Keep old app
			}
			uint8_t ok = FW_OK;
			HAL_UART_Transmit(&huart1, &ok, 1, HAL_MAX_DELAY);
			flash_erase_range(CUR_START, CUR_SIZE - PAGE_SIZE);
			uint32_t addr = CUR_START;
			uint32_t received_crc = 0xFFFFFFFFu;  // Init for crc32_calc
			for(uint32_t i = 0; i < fw_size; i += CHUNK_SIZE) {
					uint32_t len = (fw_size - i < CHUNK_SIZE) ? (fw_size - i) : CHUNK_SIZE;
					HAL_UART_Receive(&huart1, buf, len + 1, HAL_MAX_DELAY);  // Data + checksum
					uint8_t chunk_cs = 0;
					for(uint32_t j = 0; j < len; j++) chunk_cs ^= buf[j];
					if(chunk_cs != buf[len]) {
							uint8_t err = FW_ERR;
							HAL_UART_Transmit(&huart1, &err, 1, HAL_MAX_DELAY);
							return;  // Abort, keep old
					}
					for(uint32_t j = 0; j < len; j++) received_crc = crc32_update(received_crc, buf[j]);
					flash_write(addr, buf, len);
					if (flash_write(addr, buf, len) == -1) {
							uint8_t err = FW_ERR;
							HAL_UART_Transmit(&huart1, &err, 1, HAL_MAX_DELAY);
							flash_erase_range(CUR_START, CUR_SIZE);
							copy_partition(PART_OLD, PART_CURRENT);
							return;
					}
					uint8_t ack = FW_ACK;
					HAL_UART_Transmit(&huart1, &ack, 1, HAL_MAX_DELAY);
					addr += len;
			}
			received_crc = ~received_crc;
			if(received_crc != fw_crc) {
					uint8_t err = FW_ERR;
					HAL_UART_Transmit(&huart1, &err, 1, HAL_MAX_DELAY);
					return;  // Keep old
			}
			app_footer_t footer = {FOOTER_MAGIC, 1, fw_size, fw_crc, 0x00010000};  // Version example
			write_footer(CUR_FOOTER_ADDR, &footer);
			// Set pending for FR2
	}
	
	boot_ctrl_t bcb;
	read_bcb(&bcb);
	bcb.pending = 1;
	bcb.boot_target = PART_CURRENT;
	bcb.trial_count = 3;  // e.g., 3 trials
	write_bcb(&bcb);
	HAL_NVIC_SystemReset();  // Reset to boot new
}

static void copy_partition(part_t src, part_t dst) {
    uint32_t src_addr = part_base(src);
    uint32_t dst_addr = part_base(dst);
    uint32_t size = (src == PART_CURRENT) ? CUR_SIZE - PAGE_SIZE : OLD_SIZE - PAGE_SIZE;
    flash_erase_range(dst_addr, size);
    uint8_t buf[PAGE_SIZE];
    for(uint32_t i = 0; i < size; i += PAGE_SIZE) {
        memcpy(buf, (void*)(src_addr + i), PAGE_SIZE);
        flash_write(dst_addr + i, buf, PAGE_SIZE);
    }
    app_footer_t f;
    read_footer((src == PART_CURRENT) ? CUR_FOOTER_ADDR : OLD_FOOTER_ADDR, &f);
    write_footer((dst == PART_CURRENT) ? CUR_FOOTER_ADDR : OLD_FOOTER_ADDR, &f);
}

=========
main.c

int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
	boot_ctrl_t bcb;
	read_bcb(&bcb);
	if(bcb.pending) {
			bcb.pending = 0;
			bcb.trial_count = 0;
			write_bcb(&bcb);
	}
  MX_USART1_UART_Init();
  /* USER CODE BEGIN 2 */
	bootloader_main();    // G?i vào bootloader
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}
=========